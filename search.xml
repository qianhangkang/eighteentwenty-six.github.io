<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记一次在某多上购买到假货维权的经历</title>
      <link href="/2019/11/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8%E6%9F%90%E5%A4%9A%E4%B8%8A%E8%B4%AD%E4%B9%B0%E5%88%B0%E5%81%87%E8%B4%A7%E7%BB%B4%E6%9D%83%E7%9A%84%E7%BB%8F%E5%8E%86/"/>
      <url>/2019/11/07/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%9C%A8%E6%9F%90%E5%A4%9A%E4%B8%8A%E8%B4%AD%E4%B9%B0%E5%88%B0%E5%81%87%E8%B4%A7%E7%BB%B4%E6%9D%83%E7%9A%84%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>大战奸商，坚定维权！</p><a id="more"></a><h1 id="记一次在某多上购买到假货维权的经历"><a href="#记一次在某多上购买到假货维权的经历" class="headerlink" title="记一次在某多上购买到假货维权的经历"></a>记一次在某多上购买到假货维权的经历</h1><h1 id="发现异常"><a href="#发现异常" class="headerlink" title="发现异常"></a>发现异常</h1><p>​        由于最近经常使用到的EltaMD的泡沫洗面奶用完了，于是准备在上一次购买的某多商家那再买一瓶，可惜换了账号没找到，遂随便找一了家看起来还靠谱的价格又便宜:)的店铺买了两瓶。几天后到货第一次使用，挤出洗面奶后明显得闻到一股刺鼻味，与之前买的几瓶有着淡淡清香的完全不同，但是第一次使用也没注意，直到后面几次使用后越发觉得不对劲，于是找了店家开始第一次询问，如下图…</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8pvd2lhb5j30u05gx7q8.jpg" alt="img1"></p><h1 id="大战奸商"><a href="#大战奸商" class="headerlink" title="大战奸商"></a>大战奸商</h1><p>好吧，那就照着商家说的做个对比。</p><p>于是将某多上的洗面奶与之前未扔掉的包装做对比，同时对照商家的说法，发现一些明显的不同，同时借助搜索引擎比对，我越发觉得不对劲，疑点如下：</p><ol><li>商家说有多种味道，但是从官网和搜索引擎上都没有找到类似的说法</li><li>商家发的最后一张真假对比图，被认为是假的洗面奶下面多了<code>net</code>一个单词，但是我发现官网、各大电商平台上的缩略图以及原先购买的洗面奶上都有这个单词</li><li>对比某多商家购买的洗面奶和之前正品的洗面奶的商品包装外壳、包装上打印的字体、商品底部的过期时间可以发现明显的不同</li></ol><p>同时，为了确认最后一张真假对比图的差别在哪，特意找了商家确认，如下图…</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8pvmnbj95j30u035sjyn.jpg" alt="img2"></p><p>OK，商家自己也说了多了net的包装是假的，开始反驳，如下图…</p><blockquote><p>我觉得非常精彩hhhhh</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8pvpwagqmj30u04kj4j1.jpg" alt="IMG_820"></p><p>商家看了半天，沉默了半天，于是一个电话打了过来，大致如下…</p><blockquote><ol><li>说net是有两个版本的，都是真的</li><li>印刷错误的那个”,”，商家说不懂英语，不太清楚，我让他随便找个学过英语的人问问</li><li>其他的没有正面回应</li><li>怀疑我是打假团队的…我明确回复他不是（打假团队为了这两百不到跟你在这扯皮？）</li><li>说我不满意的话可以退换货，还说这次栽到我手上了（潜台词是被我抓到卖假货？不过商家始终没有承认…）</li><li>我想起《消法》，就说我认为你这是假货，按照消费者权益法需要退一配三（维护消费者最基本的权益没毛病吧）</li><li>商家不同意，说他小学一年级没毕业不懂这个（难怪也不懂印刷的低级错误 ）…说退货可以其他没门，你爱咋的咋的</li></ol></blockquote><p>​        </p><p>​         这年头卖个假货还这么嚣张，遂找某多的官方客服，客服听了我的描述后说转给专人处理，三天内给我回复…</p><p>写到这已是深夜…想到三天内客服是否会给我回复我也是忐忑…大不了找消费者协会去，这次这个权我是维定了。</p><p>待更新…</p><hr><p><strong>2019年11月08日更新</strong></p><p>今天上午十点错过了某多的客服电话….</p><hr><hr><p><strong>2019年11月23日更新</strong></p><p>中间陆陆续续有些事情耽误了</p><p>错过某多的客服电话之后的某晚，又一次接到了客服电话，起初问我有什么诉求（重申假一赔十），然后让我将货物寄回某个地址，并申明会在1~3个月内有结果。遂将购买的两瓶假货寄回。</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g98amwqkorj30u015mkda.jpg" alt="IMG_0888"></p><p>十几天后突然收到短信，如下：</p><p><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g98anbnj3ej30v90pldu7.jpg" alt="IMG_0889"></p><p>于是前往购买的店铺查看该商品，已下架~</p><p>So，当自己的权益被侵害的时候，勇敢得站出来吧</p><hr><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 杂七杂八 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【转载】房价永远不会和葱等价，却远比你想象的要便宜</title>
      <link href="/2019/11/02/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%88%BF%E4%BB%B7%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E5%92%8C%E8%91%B1%E7%AD%89%E4%BB%B7%EF%BC%8C%E5%8D%B4%E8%BF%9C%E6%AF%94%E4%BD%A0%E6%83%B3%E8%B1%A1%E7%9A%84%E8%A6%81%E4%BE%BF%E5%AE%9C/"/>
      <url>/2019/11/02/%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%88%BF%E4%BB%B7%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E5%92%8C%E8%91%B1%E7%AD%89%E4%BB%B7%EF%BC%8C%E5%8D%B4%E8%BF%9C%E6%AF%94%E4%BD%A0%E6%83%B3%E8%B1%A1%E7%9A%84%E8%A6%81%E4%BE%BF%E5%AE%9C/</url>
      
        <content type="html"><![CDATA[<p>文章转载</p><a id="more"></a><h1 id="一、房价只涨不跌？-这本身就是个伪命题"><a href="#一、房价只涨不跌？-这本身就是个伪命题" class="headerlink" title="一、房价只涨不跌？ 这本身就是个伪命题"></a>一、房价只涨不跌？ 这本身就是个伪命题</h1><p>我很少愿意去说国内的东西，所以今天要说到这样的话题，我也会尽量去规避，避免犯忌讳。</p><p>那么从经济周期来说，任何经济体，都有周期，任何行业，都有兴衰。</p><p>循环往复，周而复始。</p><p>对于改革开放数十年间来说，对于一个人或者一代人，时间都足够久了，毕竟人生短暂。</p><p>但对于经济体来说，反而短的不到走完一个圈。</p><p>今天不想说别的东西，就说房价。</p><p>那就说说房地产行业的历史。</p><p>中国的房地产市场发展，按照年份来算，分五个阶段。</p><p>1978-1991年是初步发展阶段。</p><p>1992-1993年是过热期。</p><p>1994-1997年是调整期。</p><p>到这，算一个循环，发展到过热，再到调整。</p><p>不过这里呢，代表的是海南一地的房地产泡沫，调整的周期也主要是海南，所以算一个小循环，或者说试点，即便是经历了97的亚洲金融风波，主要受波及的，也只有香港，内地受影响较小。</p><p>而从1998年开始，全国寻找新的经济增长点，房地产全方位市场化，才是真正意义上的房地产市场化改革，因为是全国性的。</p><p>那么如果把1998年定为全国房地产初步发展阶段的元年。</p><p>那么2007年随着房价的上涨，以及美国次贷危机的爆发，定义为过热元年我觉得问题不大。</p><p>那么从世界的历史来看，无论是美国还是日本，都经历了初步发展阶段，过热，以及调整或者说泡沫刺破回归的过程，我们会不会例外？我认为不会，当然这是主观看法。</p><p>而从我们本土的发展来看，海南在作为房地产试点，也经历了发展，过热，调整这样的循环，说明我们的市场特性，也是符合市场化的。</p><p>那么现在拿到全国范围内，为什么就会有这么多的人不认同呢？</p><p>其实很简单，一个是我们只经历过发展，和过热，但没有经历过冷却期。</p><p>大多数人没经历过的事情，除了真正了解的人，大多数人，是很难以理解的。</p><p>而在少部分构建者比如大房地产商的主导，以及大多数房屋拥有着作为既得利益群体的盲从之下，加上市场效应，于是中国房价不跌的神话，就此产生。</p><p>#二、神话的延续？还是庞氏骗局的确认</p><p>真正的谎言，不是连基本逻辑都说不通的妄语，而是看似建立在合理的逻辑下经不起仔细推敲的谬论。</p><p>这话是我说的，喜欢的朋友可以记下来，尤其适用于金融，经济领域。</p><p>中国房价不会跌的庞氏骗局，也是如此，有着自己的一套看似合理实则完全不可能的逻辑之上。</p><p>假定，中国人口一直增加，中国经济保持双位数增长，那么，中国房价永远都不会跌，只会不停滞的往上涨。</p><p>这是前提，也是这个庞氏骗局成立的基础。</p><h1 id="三、那么真的是这样吗？"><a href="#三、那么真的是这样吗？" class="headerlink" title="三、那么真的是这样吗？"></a>三、那么真的是这样吗？</h1><p><img src="https://i.loli.net/2019/11/02/x1gS8BkeFOJACqy.png" alt="img"></p><p>这是我自己做的图，从这个图表中可以清晰地看到，无可否认，中国人口有过爆发式增长，且从1960至今都是单边增长的。</p><p>但如果仔细去看，其实很清晰的可以看到问题所在。</p><p><img src="https://i.loli.net/2019/11/02/xSt3W6aQpewXVhd.png" alt="2.png"></p><p>这张图是按人口增幅来计算的，当然，随着人口总量的提升，技术上去了，比例下来了是正常的，但下来的如此之快，这是有问题的，说明人口增速的放缓和爆发式人口增速的不可持续性。</p><p><img src="https://i.loli.net/2019/11/02/OxXgMih58tFfbYy.png" alt="3.png"></p><p>再去把每年的人口增量做一个统计图，就会发现，在人口高爆发期过后，每年人口增量在大幅度地减少。</p><p>其实把这个如果做成k线图，就非常有意思了。</p><p>由于关注我的朋友们很多都有在炒股或者其他形式的投资，或者还在进行，或则曾经接触过。</p><p>所以对量价定律大多数都很熟悉。</p><p>那么把人口总数当做股价，而人口增速当做量能，很有意思的事情发生了。</p><p>随着不断升高的人口总量和日益减少的人口增量，很清晰的量价背离关系就出来了。</p><p>要放在金融市场来说，这是量价背离要大跌的节奏~</p><p>而事实上，也是如此。</p><p>中国近70年的人口增长的密集周期，集中在1960-1979，差不多也就是我父辈那一代人。</p><p>而在1982年12月之后，随着计划生育定为国策，列为宪法之后，人口增速就出现了明显的放缓，尤其在1985之后，新生儿出生率有明显的下降。</p><p>这个时代，诞生了一个名词，叫独生子女。</p><p>所谓的独生子女是怎么回事呢？就是一个家庭有父母构成，新生人口为1，换句话说，人口递增速率由1下降至0.5。</p><p>这就是八零后这一代。</p><p>而八零后这一代在成长，比较极端的是双独生子女家庭结合，抚育1个孩子。</p><p>也就是夫妻双方4个长辈，到这一代人口增速是四分之二，也就是两个独生子女养育一个独生子女。</p><p>也就是祖孙三代的人口变化从4变2，2变1。</p><p>尽管随着中国医疗条件的变化，中国人口寿命有着显著提高，目前中国人口的平均寿命是74.3岁。</p><p>但问题在于，人口出生率高爆期在1960-1979这二十年间。</p><p>从那之后，人口出生率就再也没有超过那个时期的了。</p><p>这意味着什么呢？一旦这一批在人口基数中占据最大比重的一个年龄层跨度的居民临近目前这个74.3的分界线。</p><p>中国人口总量会出现递减，因为新生儿出生率不及老零化程度。</p><p>今年是2019，中国人口高爆期第一个梯队的，也就是1960年出生的人，已经59了。</p><p>而这个问题在于，即便是现在开始，二胎政策执行的非常到位，履行率达60%以上，也改变不了结果。</p><p>所以未来的人口总数，从目前看，下降是大概率的。</p><p><strong>这其一，也就是证伪这个庞氏骗局第一重逻辑论述的结论。</strong></p><p>其二是中国人人均可支配财富持续性。</p><p>2018年，全国居民人均可支配收入28228元，比上年名义增长8.7%，扣除价格因素，实际增长6.5%。其中，城镇居民人均可支配收入39251元，增长(以下如无特别说明，均为同比名义增长)7.8%，扣除价格因素，实际增长5.6%;农村居民人均可支配收入14617元，增长8.8%，扣除价格因素，实际增长6.6%。</p><p>这个数据呢是官方公布的数据，当然首先不能看名义，而要看实际，也就是应该当6.5%来看。</p><p>而名义增长8.7%这个我觉得争议的地方不大，争议的是扣除价格因素之后，是不是6.5%。</p><p>也就是扣除了通胀，货币贬值等直接影响货币购买力的因素之后，到底实质是多少的问题。</p><p>再去看2018年的消费支出。</p><p><img src="https://i.loli.net/2019/11/02/qGBpsjPkXgcoFH2.png" alt="4.png"></p><p>全年全国居民人均食品烟酒消费支出5631元，比上年增长4.8%;人均衣着消费支出1289元，增长4.1%;人均居住消费支出4647元，增长13.1%;人均生活用品及服务消费支出1223元，增长9.1%;人均交通通信消费支出2675元，增长7.1%;人均教育文化娱乐消费支出2226元，增长6.7%;人均医疗保健消费支出1685元，增长16.1%;人均其他用品及服务消费支出477元，增长6.8%。</p><p>可以看到，随着刚性消费，也就是医疗，教育，居住等刚性消费支出的增速快速上行，已经严重影响到类似于食品烟酒，衣着消费，文娱等可选项消费的支出增长。</p><p><strong>所以，在剔除这些因素之后，人均可支配财富的名义增长，扣除实质之后，真的还站得住脚说人均实质可支配财富持续增长吗？在扣除其他增量支出之后？在扣除实质通胀和货币贬值之后？</strong></p><p><strong>所以支撑另一个房价不败的神话的逻辑，也是个伪命题。</strong></p><p>尤其近年来，中国经济增速放缓的过程中，越来越多裸泳的人和企业，会浮出水面。</p><h1 id="四、谨记一个名词，叫负资产"><a href="#四、谨记一个名词，叫负资产" class="headerlink" title="四、谨记一个名词，叫负资产"></a>四、谨记一个名词，叫负资产</h1><p>在历史上每一个出现房地产泡沫的国家，都有一个名词被人铭记，叫负资产。</p><p><strong>如果用在房产经济里面，负资产的意思，就是你在交完40%的首付之后，在未来的某一段时间里，你发现你房产的价格，还不及你要接着缴纳的房贷价值高。</strong></p><p>这一点，美国，日本，乃至中国的香港，都在房地产泡沫破裂后出现过，我相信我们也不会例外。</p><p>尤其在当前，房产价值在家庭财富总量普遍达到75%以上的社会环境和历史环境里边。</p><h1 id="五、真正构成房价下跌的驱动"><a href="#五、真正构成房价下跌的驱动" class="headerlink" title="五、真正构成房价下跌的驱动"></a>五、真正构成房价下跌的驱动</h1><p>中国的房地产资产价格，真的值这么多钱吗？</p><p>这个问题，其实很简单，不可能值这么多钱的。</p><p>之所以炒到这个价格，就因为具备了金融性。</p><p>这一点，就和中国社会是不是真的富裕到两千多一瓶的茅台供不应求的的话题是一样的。</p><p>那么先去说金融新，房地产属性中的金融性，体现在哪里呢？</p><p>一个是增值保值，说白了就是房价在过去的20年里面几十倍的往上涨，远超居民收入增长速率和GDP增长速率。</p><p>所以房产的第一个金融属性，增值保值属性，就被发挥的淋漓尽致，房价节节攀升之下，自然就形成了套利机制。</p><p>过去将近20年的历史里面，形成了一个畸形共识，就是做实业不如炒房子赚钱。</p><p>这是不是和九十年代要发财到海南，要赚钱炒楼花非常相似？</p><p>可眼下高层一而再再而三的强调房住不炒的大基调下，<strong>我不说房价会跌，那房价会继续涨，有人认同吗？</strong></p><p>如果认同，那就问题来了。</p><p><strong>资本最核心的特性，就是逐利。</strong></p><p>以当前中国的房价水准而言，一套房产动则上百万，二线城市动则数百万，而一线，核心价值区域，以千万计算，是当前的实际状况。</p><p><strong>那么问题一，当房价天花板被锁死的情况下，这些动则以百万千万计的资本，锁在房产里，升值空间大，还是贬值空间大，能跑赢银行基准利率的年收益，有多少比例？</strong></p><p>这是当房价天花板被锁死的情况下，资本所需要考虑的第一个问题。</p><p><strong>问题二：**</strong>当一类资产收益率，连银行基准利率都跑不赢的前提下，是属于优质资产，还是劣质资产，资本是会选择持有，还是转换寻找更好标的。**</p><p>这是不考虑房价下跌的情况下要考虑的两个资本属性问题。</p><p>我个人的答案而言，当前的房产，在刨除居住属性之外，不属于优质资产，而应该从投资属性的角度归类为劣质资产，而且同时面临的，是行政高压和市场虚无需求的幻想面临回归和泡沫破裂风险的高危资产。</p><p>那接下来说第二个问题。</p><p>就是房产里面的资产套保问题。</p><p>在房价上涨的过程中，房子是很火热的信誉品种，拿着房产去抵押，轻松就可以融资。</p><p>比如说你急需用钱，需要卖房子去套利吗？不需要的，只要你拿着房本去抵押，轻松就可以拿到银行的低息贷款。</p><p>等贷款换上了，享受了低息借贷的你一回头，发现房价上涨带来的投资收益比支付银行的低息利率，要划算的多。</p><p>所以，很多人脑子里想的是，就算是房价不涨了，我拿着当资产，必要的时候还可以融资，多好，说实话，打这种算盘的人，不在少数。</p><p>但是，这同样是一个庞氏骗局。</p><p>在银行工作或者说有过房屋抵押贷款经验的人可能比较了解一些。</p><p>那就是决定银行批贷与否的一个非常关键性的问题，就是房龄。</p><p>这是绝大多数炒房客们，都还没经历过的。</p><p><strong>国内的大行们，最严格的的应该是工行建行等银行。</strong></p><p><strong>处于资金风控问题，超过20年房龄的，这些银行是很难敲开大门的，批贷，除了少量特殊情况的房源，其他的基本上别想了。</strong></p><p><strong>中信银行，中国银行的受理年限，是房龄25年以内的。</strong></p><p><strong>招商银行差不多是最宽松的，30年。</strong></p><p>而房屋抵押贷款的放贷比例，同样是看房龄的。</p><p><strong>房龄15年以下的房子，可申请的总贷款为房价的七成。</strong></p><p><strong>房龄15-20年的房子，可申请的总贷款为房价的六成。</strong></p><p><strong>房龄20-25年的房子，可申请的总贷款为房价的只有五成。</strong></p><p>所以，在排除房价上涨的情况下，房屋资产套保，是一年比一年差的。</p><p>所以除非保证房价上涨，房屋资产套保的思路，其实很傻。</p><p>还要注意下，这个房龄，不是你购买新楼盘拿到房本的日期，更加不是二手房价过户的日期，而是备案的建筑日期。</p><p>所以都好好看看自家房本上的建筑日期吧。</p><h1 id="六、中国的房价，什么时候会开始跌？"><a href="#六、中国的房价，什么时候会开始跌？" class="headerlink" title="六、中国的房价，什么时候会开始跌？"></a>六、中国的房价，什么时候会开始跌？</h1><p>如果按照正常逻辑测算，中国的房价最晚，不会超过2019年，就会出现下跌。</p><p>因为中国的楼市，其实是从1998年开始启动的，正好是第一批。</p><p>而这时候，从来没经历过房地产泡沫的大多数国人，还从来不知道拿着房地产市场化第一梯队，也就是1998年的房子，从一些风控严格的银行里拿不到贷款批文的经历。</p><p>过往房价牛市的时候，从来都是拿着房产证去贷款一路顺风水顺的。</p><p>那么这是第一轮恐慌，拿着房产当资产的人，发现贷不出钱了，然后会波及临近年份的房产，再到波及到所有年份，进而对房产是否值得持有画上疑问。</p><p>这是按照逻辑最晚的推算。</p><p>但实际上，是更早。</p><p>有过A股投资经验的朋友，应该知道，高位密集放量通常意味着什么。</p><p>这同样适用于楼市，在2016年，中国楼市市场最疯狂的交易周期。</p><p>这一年尤其下半年，成交量和价格都出现暴增，而且是极不寻常的暴增。</p><p>以数倍的成交量放大，价格暴涨。而就在最疯狂的时候，限购限售出来了。</p><p>不同年份和各种条件门槛的限购出台，限售大多数是五年，理由是避免市场过度疯狂。</p><p>其实本质，是流动性锁死。</p><p>没有成交，自然价格就下不来。</p><p>而2016年在房地产市场成交量最大的，价格最高的时候锁死流动，用金融术语来说，不是套牢，而是冻结。</p><p>原本的房地产市场，就像是A股里的优质和散户，涨了就可以套利，甚至今天买的便宜，明天涨幅较大，随时就可以套利撤出，这就是2016年的楼市。</p><p>买入房产过几个月或者过几个礼拜就卖出套利的比比皆是。</p><p>这时候的房产投机者，跟A股里的游资和散户特别像。</p><p>但随着限购限售的出台，成交量密集区域的2016，全部属于限售范围。</p><p>于是乎，原本像A股里的游资和散户随买随卖的房产投机客们，一瞬间摇身一变，就成了大股东了，大股东的持仓可以卖吗？当然可以啦，五年后，谢谢~</p><p>同样的问题，如果说A股在5178的时候公布一条政策，股票买入卖出，限售五年，我保证，现在股市还是五千点上方。</p><p>这个时候房产投资者，应该多问问股民，大股东解禁日期到来或者临近的时候，通常股价会怎么反应。</p><p>要知道，在2016年到2021年这五年里，受到房住不炒的大方向指引，房价整体表现是平坦的。</p><p><strong>换句话说，这世上最大的一批房产套牢盘，虽然因为流通性锁死的情况下，房价没有跌，但肯定也是不赚钱的。</strong></p><p><strong>换句话说，如果房住不炒的大方向得到彻底贯彻，到2021年，这批最大的房地产投机客们限售的枷锁被打开后，房地产市场将迎来的是房地产市场上规模最大，但五年没有赚到钱，且很多要背负这五年期间的利率损失，以及五年连银行利率和通胀都跑不赢的房产套牢盘解禁周期。</strong></p><p>想想都觉得可怕，这批煎熬了五年的资本会有多疯狂！</p><p>到时候怎么办？</p><p><strong>再一次房地产去库存？不可能的，上一轮的房地产去库存之后，平均居民杠杆率从15%到超过50%，不可能支撑新一轮房地产去库存的动作了。</strong></p><p><strong>再叠加一次限售？从五年到十年？在锁他个五年？</strong></p><p><strong>那恐怕楼市里的资本，真的会疯了，所以也不可能。</strong></p><p>所以强锁的这五年，其实最大的作用是拖个五年，先把问题压下来，然后争取在五年以内拿出一个解决的办法，去化解这以万亿为规模的金融风险。</p><p>以目前看，这个办法应该就是大力搞基建，推一带一路，也只有这个能承载足够的权重去换取喘息的时间，也只有这个能够立竿见影。</p><p>比如说要换一个，搞5G，搞芯片，搞高科技，等这些技术成熟，形成一个足以替代房地产在经济中的比重和权重，那个周期到来之前，黄花菜都凉了。</p><p><strong>所以只能是基建，量体够大，稳定效率够快，搞得起来得搞，搞不起来创造条件也得搞。</strong></p><p>为什么我们近年来对外态度这么坚决？</p><p><strong>难道集中国智慧之精华的智囊团看不到把一带一路推出来之后，会加剧以贸易分歧为代表实则是影射国际海外利益分配上和某国的分歧的实质吗？</strong></p><p>不是，<strong>只是因为一切为了降低2021年这一天到来前，能够形成一个足够庞大和结实的缓冲气垫。</strong></p><p><strong>那么现在，一直关注我的朋友们，理解了吗？为什么我从2018年年初，贸易分歧之初，就坚定不移的认为我们绝不可能妥协，没有退让空间，所以必然是一场漫长的持久战的原因？</strong></p><p><strong>概因为，我看到了，这是一场只能赢不能输也输不起的博弈，无论如何也必须要攻克的一个高地，概因为，这已经是唯一的解法了。</strong></p><p><strong>2021，比绝大多数人想象的，都要难！</strong></p><p><strong>理解了吗？为什么我这几年但凡发文，总要唠叨几句，尽可能配置点黄金。</strong></p><p><strong>概因为，我在2015看到了未来的2021。</strong></p><p>这篇文章，如果能有幸发布，喜欢的朋友，保存起来吧，2021，你可以拿出来看。</p><p>本来是想轻松的写一篇娱乐一下的，不由自主又认真了。</p><p>今天想说的，就说到这吧，希望不会让你周末的心情变得沉重，也是我第一次把从2015到现在的一些东西说出来。</p><p><strong>可喜的是，黄金总算是不复众望一路高歌猛进到了今天的位置，可悲的是越是这样，我越觉得自己是对的，至少这次，我希望自己是错的。</strong></p><p>就说到这吧，不知道我今天成功的让多少人不开心了，sorry。</p><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 转载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2019/11/02/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/11/02/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>Java内存模型（Java Memory Model）。</p><p>当初曾和Java运行时内存区域混淆了。。。</p><a id="more"></a><h1 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h1><blockquote><p>Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。在此之前，主流程序语言如C/C++等 直接使用物理硬件和操作系统的内存模型，因此，会由于不同平台上内存模型的差异，有可能导致程序在一套平台上并发完全正常，而在另一套平台上并发访问却经常错误，因此在某些场景就必须针对不同的平台来编写程序。</p><p>定义Java内存模型并非一件容易的事情，这个模型必须定义得足够谨慎，才能让Java的并发访问操作不会产生歧义；但是，也必须定义得足够宽松，使得Java虚拟机的实现有足够的自由空间去利用硬件的各种特性（寄存去、高速缓存和指令集中某些特有的指令）来获取更好的执行速度。</p></blockquote><h2 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h2><p>交互图：</p><p><img src="https://i.loli.net/2018/08/24/5b7f7665b7e96.png" alt="Java内存模型.001.png"></p><p>Java内存模型规定了所有的变量都存储在主内存中。每个线程拥有自己的工作内存，工作内存用于保存该线程在主内存中使用到的变量的副本拷贝，线程对该变量的操作都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存的变量，线程之间变量值的传递都需要通过主内存来完成。</p><h2 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h2><ol><li>lock，作用于主内存中的变量，它会将一个变量标识为一条线成独占的状态</li><li>unlock，同上，不过它将变量从锁定状态释放出来</li><li>read，作用于主内存，该操作将主内存中的变量传递到某个Java线程的工作内存中</li><li>load，作用于工作内存的变量，该操作将read过来的变量赋值给工作内存中的变量</li><li>use，作用于工作内存的变量，该操作将工作内存中的变量传递给执行引擎使用</li><li>assign，作用于工作内存的变量，该操作将执行引擎中接受的变量赋值给工作内存中的变量</li><li>store，作用于工作内存的变量，该操作将工作内存中的变量传递到主内存中</li><li>write，作用于主内存中的变量，该操作将store过来的变量赋值给主内存中的变量</li></ol><h2 id="volatile变量"><a href="#volatile变量" class="headerlink" title="volatile变量"></a>volatile变量</h2><p>volatile变量是Java中的一个关键字，是Java虚拟机提供的最轻量的同步机制。</p><p>volatile修饰的变量保证了不同线程对该变量的可见性和有序性（禁止指令重排序），但无法保证该变量的原子性</p><ul><li><p>当一个线程对volatile修饰的变量进行读操作的时候，会强制从主内存中read该变量的值，然后load其工作内存中的变量；当进行写操作的时候，会强制将工作内存中的变量store进主内存中，主内存再进行write操作。这样就保证了其他线程对于该变量的可见性。</p><p>从字节码的角度来看，一个被volatile修饰的变量赋值后，编译器会自动执行一个lock的空操作，该空操作会强制本CPU的cache写入主内存中，该写入动作也会导致别的CPU中的cache无效化，这种操作就相当于刚才说的store和write操作</p></li><li><p>volatile会禁止指令重排序。普通的变量仅仅保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到结果，但不能保证与程序代码的执行顺序一致。volatile修饰的变量会产生一个内存屏障，就是lock一个空操作，该操作后的指令不能被重排序到该指令之前</p></li></ul><h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><p>可见性是指当一个线程修改了共享变量的值，其他线程能够立刻得知这个修改。</p><h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><p>有序性指的是在本线程内观察，所有操作都是有序的；在一个线程中观察另一个线程，所有的操作都是无序的。前半句指的是“线程内表现为串行的寓意”，后半句是指“指令重排序”现象和“工作内存与主内存延迟同步”的现象</p><h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><p>Java内存模型直接保证的原子性变量操作包括read、load、use、assign、store、write。原子操作保证了这些操作要么都做了，要么都没做</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《深入理解Java虚拟机》——周志明</p><p><a href="http://www.techug.com/post/java-volatile-keyword.html" target="_blank" rel="noopener">http://www.techug.com/post/java-volatile-keyword.html</a></p><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网易面试整理</title>
      <link href="/2019/11/02/%E7%BD%91%E6%98%93%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
      <url>/2019/11/02/%E7%BD%91%E6%98%93%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>网易总部面试，一些问题（顺序不分先后）记录于此，同时也鞭策我继续前行 :)</p><a id="more"></a><h1 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h1><ol><li>关于项目上的问题（因人而异）</li><li>RABC的思想介绍下</li><li>shiro是如何实现权限控制的</li><li>TCP的三次握手和四次挥手说下，四次挥手客户端和服务器的状态</li><li>TCP的拥塞控制怎么做的</li><li>TCP怎么进行流量控制的</li><li>SSM和springboot有什么区别吗</li><li>他们之间的部署方式有区别吗</li><li>spring的aop是怎么实现的</li><li>一个类被final修饰还能使用cglib代理吗</li><li>spring的事务传播机制</li><li>spring的事务隔离机制</li><li>脏读和幻读有什么区别</li><li>ThreadLocal的原理是什么？ThreadLocalMap中key存的是什么？</li><li>说一下JVM的内存结构</li><li>方法区中的代码是线程安全的吗？那栈中的呢？为什么？</li><li>JVM会发生内存泄漏吗？给一段内存泄漏的代码</li><li>说一说gc的机制</li><li>Redis的部署模式知道吗？比如哨兵模式？</li><li>线程池的原理有了解过吗？</li><li>线程有哪几个状态？</li></ol><h1 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h1><ol><li>spring源码有了解过吗？</li><li>spring的bean的生命周期说下</li><li>spring的特性有哪些？</li><li>spring如何实现aop的？</li><li>spring如何选择使用哪种动态代理？</li><li>spring cloud有了解吗？有哪些组件？哪些可以作为服务发现？</li><li>CAP理论能说一说吗？</li><li>Redis如何进行分布式部署？</li><li>你知道哪些消息队列？kafka有了解吗？</li><li>ES了解吗？他的架构是什么？</li><li>MySQL事务的默认隔离级别是什么？</li><li>能够解决幻读的问题吗？</li><li>MVCC原理是什么？是数据库底层自动处理还是需要代码解决？</li><li>你了解哪些非关系型数据库？</li><li>MySQL数据能直接转到MongoDB吗？代码需要改变吗？</li><li>ConcurrentHashMap各版本之间有什么不同？</li><li>反向代理服务器有了解吗？</li><li>HTTP的请求头中有哪些？</li><li>keep-alive了解吗？</li><li>JVM内存结构说下</li><li>1.8版本之后增加了什么区域？</li><li>元数据是什么？</li><li>什么时候会发生full gc</li><li>垃圾回收的几种算法说下？分别适用哪些区域？</li><li>给了一段SQL:where a = ? and b = ? order by c，abc均不是主键，请设计一个索引，并解释为什么？</li><li>一个shell脚本的问题</li></ol><h1 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h1><p>谈实习谈职业发展规划，顺口问了下我期望的薪资。。。</p><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于单例模式的几种实现方式</title>
      <link href="/2019/11/02/%E5%85%B3%E4%BA%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/"/>
      <url>/2019/11/02/%E5%85%B3%E4%BA%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>单例模式是一种常用的设计模式，存在多种实现方式</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>有一些对象我们只需要一个即可，如线程池、缓存、对话框、处理偏好设置和注册表的对象、日志对象、充当打印机、显卡等设备的驱动程序的对象</p></blockquote><h1 id="饿汉式加载"><a href="#饿汉式加载" class="headerlink" title="饿汉式加载"></a>饿汉式加载</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance = new Singleton();</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        //private constructor</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用这个做法，JVM加载这个类的时候马上创建此唯一的实例，但是可能会出现占用内存、不曾使用这个类而浪费内存等问题</p><h1 id="粗暴式同步"><a href="#粗暴式同步" class="headerlink" title="粗暴式同步"></a>粗暴式同步</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static Singleton instance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        //private constructor</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static synchronized Singleton getInstance() &#123;</span><br><span class="line">        return instance == null ? new Singleton() : instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用synchronized关键字可能会导致性能问题</p><h1 id="双重锁"><a href="#双重锁" class="headerlink" title="双重锁"></a>双重锁</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private volatile static Singleton instance;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        //private constructor</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if (instance == null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if (instance == null) &#123;</span><br><span class="line">                    return new Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">                return instance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程安全，但是有可能被序列化破坏单例模式。如下代码破坏了单例模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DestroySingleton &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException, ClassNotFoundException &#123;</span><br><span class="line">        ObjectOutputStream ostream = new ObjectOutputStream(new FileOutputStream(&quot;singleton&quot;));</span><br><span class="line">        ostream.writeObject(Singleton.getInstance());</span><br><span class="line"></span><br><span class="line">        ObjectInputStream istream = new ObjectInputStream(new FileInputStream(new File(&quot;singleton&quot;)));</span><br><span class="line">        //从stream中读取对象会通过反射调用无参构造的方法构建一个新的对象</span><br><span class="line">        Singleton inputInstance = (Singleton) istream.readObject();</span><br><span class="line">//两者已经不是同一个对象了</span><br><span class="line">        System.out.println(Singleton.getInstance() == inputInstance);// false</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以通过实现Serializable接口重写readResolve()方法来解决序列化的问题</p><h1 id="静态内部类式"><a href="#静态内部类式" class="headerlink" title="静态内部类式"></a>静态内部类式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton &#123;</span><br><span class="line">    private static class SingletonHolder &#123;</span><br><span class="line">        private static final Singleton instace = new Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">        //private constructor</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        return SingletonHolder.instace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也是饿汉式的一种</p><h1 id="枚举类实现"><a href="#枚举类实现" class="headerlink" title="枚举类实现"></a>枚举类实现</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`public enum EasySingleton&#123;    INSTANCE;&#125;`</span><br></pre></td></tr></table></figure><p>简单，且不存在序列化的问题</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>《Head First 设计模式》</p><p><a href="http://www.hollischuang.com/archives/1144" target="_blank" rel="noopener">http://www.hollischuang.com/archives/1144</a></p><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习笔记</title>
      <link href="/2019/11/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/11/02/Redis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Redis！Redis！</p><a id="more"></a><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>Redis is an open source (BSD licensed), in-memory <strong>data structure store</strong>, used as a database, cache and message broker. It supports data structures such as <a href="https://redis.io/topics/data-types-intro#strings" target="_blank" rel="noopener">strings</a>, <a href="https://redis.io/topics/data-types-intro#hashes" target="_blank" rel="noopener">hashes</a>, <a href="https://redis.io/topics/data-types-intro#lists" target="_blank" rel="noopener">lists</a>, <a href="https://redis.io/topics/data-types-intro#sets" target="_blank" rel="noopener">sets</a>, <a href="https://redis.io/topics/data-types-intro#sorted-sets" target="_blank" rel="noopener">sorted sets</a> with range queries, <a href="https://redis.io/topics/data-types-intro#bitmaps" target="_blank" rel="noopener">bitmaps</a>, <a href="https://redis.io/topics/data-types-intro#hyperloglogs" target="_blank" rel="noopener">hyperloglogs</a> and <a href="https://redis.io/commands/geoadd" target="_blank" rel="noopener">geospatial indexes</a> with radius queries. Redis has built-in <a href="https://redis.io/topics/replication" target="_blank" rel="noopener">replication</a>, <a href="https://redis.io/commands/eval" target="_blank" rel="noopener">Lua scripting</a>, <a href="https://redis.io/topics/lru-cache" target="_blank" rel="noopener">LRU eviction</a>, <a href="https://redis.io/topics/transactions" target="_blank" rel="noopener">transactions</a> and different levels of <a href="https://redis.io/topics/persistence" target="_blank" rel="noopener">on-disk persistence</a>, and provides high availability via <a href="https://redis.io/topics/sentinel" target="_blank" rel="noopener">Redis Sentinel</a> and automatic partitioning with <a href="https://redis.io/topics/cluster-tutorial" target="_blank" rel="noopener">Redis Cluster</a>.</p></blockquote><p>Redis是一个开源（BSD许可），内存数据结构存储，用作数据库，缓存和消息代理。 它支持的数据结构有字符串，hash，列表，集合，带有范围查询的排序集，位图，超级日志和带有半径查询的地理空间索引。 Redis具有内置复制，Lua脚本，LRU驱逐，事务和不同级别的磁盘持久性，并通过Redis Sentinel提供高可用性并使用Redis Cluster自动分区。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li>速度快，最快可达到 <code>10w QPS</code>（基于 <strong>内存</strong>，<code>C</code> 语言，<strong>单进程单线程</strong> 架构）</li><li>基于 <strong>键值对</strong> (<code>key/value</code>) 的数据结构服务器。全称 <code>Remote Dictionary Server</code>。包括 <code>string</code>(<strong>字符串</strong>)、<code>hash</code>(<strong>哈希</strong>)、<code>list</code>(<strong>列表</strong>)、<code>set</code>(<strong>集合</strong>)、<code>zset</code>(<strong>有序集合</strong>)、<code>bitmap</code>(<strong>位图</strong>)。同时在 <strong>字符串</strong> 的基础上演变出 <strong>位图</strong>（<code>BitMaps</code>）和 <code>HyperLogLog</code> 两种数据结构。<code>3.2</code> 版本中加入 <code>GEO</code>（<strong>地理信息位置</strong>）</li><li>丰富的功能。例如：<strong>键过期</strong>（缓存），<strong>发布订阅</strong>（消息队列）， <code>Lua</code> 脚本（自己实现 <code>Redis</code> 命令），<strong>事务</strong>，<strong>流水线</strong>（<code>Pipeline</code>，用于减少网络开销）</li><li>简单稳定。无外部库依赖，单线程模型</li><li>客户端语言多</li><li>持久化<strong>（支持两种</strong> 持久化方式 <code>RDB</code> 和 <code>AOF</code>）</li><li>主从复制（分布式的基础）</li><li><strong>高可用</strong>（<code>Redis Sentinel</code>），<strong>分布式</strong>（<code>Redis Cluster</code>）和 <strong>水平扩容</strong></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li><p>Mac</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install redis</span><br></pre></td></tr></table></figure><p>对应的配置文件在<code>/usr/local/etc/redis.conf</code></p></li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><p>启动命令(Mac下用homebrew安装)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-server /usr/local/etc/redis.conf</span><br></pre></td></tr></table></figure></li><li><p>关闭指定端口的redis</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -p &#123;port&#125; shutdown</span><br></pre></td></tr></table></figure></li><li><p>查看redis信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info</span><br></pre></td></tr></table></figure></li></ul><h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><ol><li><p>定时删除</p><p>为设置了过期时间的key设置一个定时器。该策略可能造成占用大量的CPU时间</p></li><li><p>定期删除</p><p>每隔一段时间（配置文件中的hz，默认为10）删除已过期的key。是定时删除和惰性删除的解决方案</p></li><li><p>惰性删除</p><p>当Redis访问一个key时，判断这个key是否过期，如果过期了那么删除这个key。对CPU占用小，但是可能造成内存的浪费</p></li></ol><p><strong>Redis同时使用了定期删除和惰性删除</strong></p><h2 id="内存淘汰策略"><a href="#内存淘汰策略" class="headerlink" title="内存淘汰策略"></a>内存淘汰策略</h2><p>当Redis执行每个命令的时候都会检查当前使用的内存是否超过配置中规定的maxmemory，如果超过，那么会执行对应的内存淘汰策略</p><p>以下是redis配置文件中摘录的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># MAXMEMORY POLICY: how Redis will select what to remove when maxmemory</span><br><span class="line"># is reached. You can select among five behaviors:</span><br><span class="line">#</span><br><span class="line"># volatile-lru -&gt; remove the key with an expire set using an LRU algorithm</span><br><span class="line"># allkeys-lru -&gt; remove any key according to the LRU algorithm</span><br><span class="line"># volatile-random -&gt; remove a random key with an expire set</span><br><span class="line"># allkeys-random -&gt; remove a random key, any key</span><br><span class="line"># volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)</span><br><span class="line"># noeviction -&gt; don&apos;t expire at all, just return an error on write operations</span><br><span class="line">#</span><br><span class="line"># Note: with any of the above policies, Redis will return an error on write</span><br><span class="line">#       operations, when there are no suitable keys for eviction.</span><br><span class="line">#</span><br><span class="line">#       At the date of writing these commands are: set setnx setex append</span><br><span class="line">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span><br><span class="line">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span><br><span class="line">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span><br><span class="line">#       getset mset msetnx exec sort</span><br><span class="line">#</span><br><span class="line"># The default is:</span><br><span class="line">#</span><br><span class="line"># maxmemory-policy noeviction</span><br></pre></td></tr></table></figure><p>共有六种淘汰策略</p><ul><li><p>noeviction</p><p>对于写入操作报错，不会淘汰任何数据</p></li><li><p>allkeys-random</p><p>随机淘汰任意一个数据</p></li><li><p>volatile-random</p><p>从已设置过期的数据集中随机淘汰一个数据</p></li><li><p>allkeys-lru</p><p>根据最近最少使用策略淘汰任意一个数据</p></li><li><p>volatile-lru</p><p>根据最近最少使用过策略从已设置过期的数据集中淘汰一个数据</p></li><li><p>volatile-ttl</p><p>从已设置过期的数据集中淘汰即将过期的数据</p></li></ul><p><strong>对于上述任何策略，当没有合适的可以被驱逐key时，Redis将在写入时返回错误操作</strong></p><h2 id="持久化策略"><a href="#持久化策略" class="headerlink" title="持久化策略"></a>持久化策略</h2><ol><li><p>RDB （默认策略）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Save the DB on disk:</span><br><span class="line">#</span><br><span class="line">#   save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line">#</span><br><span class="line">#   Will save the DB if both the given number of seconds and the given</span><br><span class="line">#   number of write operations against the DB occurred.</span><br><span class="line">#</span><br><span class="line">#   In the example below the behaviour will be to save:</span><br><span class="line">#   after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">#   after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">#   after 60 sec if at least 10000 keys changed</span><br><span class="line">#</span><br><span class="line">#   Note: you can disable saving completely by commenting out all &quot;save&quot; lines.</span><br><span class="line">#</span><br><span class="line">#   It is also possible to remove all the previously configured save</span><br><span class="line">#   points by adding a save directive with a single empty string argument</span><br><span class="line">#   like in the following example:</span><br><span class="line">#</span><br><span class="line">#   save &quot;&quot;</span><br><span class="line"></span><br><span class="line">save 900 1    #after 900 sec (15 min) if at least 1 key changed</span><br><span class="line">save 300 10   #after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line">save 60 10000 #after 60 sec if at least 10000 keys changed</span><br></pre></td></tr></table></figure><p>该方式会按照指定的时间策略将数据快照（dump.rdb）文件保存在硬盘上，如果发生意外，那么数据快照可能不是最新的，可能丢失几分钟的数据</p></li><li><p>AOF</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># By default Redis asynchronously dumps the dataset on disk. This mode is</span><br><span class="line"># good enough in many applications, but an issue with the Redis process or</span><br><span class="line"># a power outage may result into a few minutes of writes lost (depending on</span><br><span class="line"># the configured save points).</span><br><span class="line">#</span><br><span class="line"># The Append Only File is an alternative persistence mode that provides</span><br><span class="line"># much better durability. For instance using the default data fsync policy</span><br><span class="line"># (see later in the config file) Redis can lose just one second of writes in a</span><br><span class="line"># dramatic event like a server power outage, or a single write if something</span><br><span class="line"># wrong with the Redis process itself happens, but the operating system is</span><br><span class="line"># still running correctly.</span><br><span class="line">#</span><br><span class="line"># AOF and RDB persistence can be enabled at the same time without problems.</span><br><span class="line"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span><br><span class="line"># with the better durability guarantees.</span><br></pre></td></tr></table></figure><p>Redis会将接受到的写命令写入到制定的文件中（默认为appendonly.aof），使用该方式持久化在遇到突发事件如断电时只会丢失一秒的写入数据，或者在Redis进程奔溃时但操作系统依旧正确的运行时只会丢失一次写入数据。</p><p>Redis有三种数据fsync策略</p><ol><li><p>appendfsync everysec</p><p>每秒将buffer中的写入命令写入到文件中。这是默认使用的策略，是一种性能和数据安全的折中策略</p></li><li><p>appendfsync no</p><p>依赖操作系统的写入，一般30s左右写入一次。性能最好，但是无法保证数据安全</p></li><li><p>appendfsync always</p><p>每个命令都会直接写入到文件中。数据安全，但性能低下</p></li></ol></li></ol><h2 id="Redis内存回收策略"><a href="#Redis内存回收策略" class="headerlink" title="Redis内存回收策略"></a>Redis内存回收策略</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><ul><li>在创建一个新对象时， 引用计数的值会被初始化为 <code>1</code> ；</li><li>当对象被一个新程序使用时， 它的引用计数值会被增一；</li><li>当对象不再被一个程序使用时， 它的引用计数值会被减一；</li><li>当对象的引用计数值变为 <code>0</code> 时， 对象所占用的内存会被释放。</li></ul><h2 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h2><h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>缓解主库压力，做读写分离（从库默认情况下无法写入，只能读取）。如果主节点down，那么只能手动恢复主节点。哨兵模式解决了自动化的故障恢复</p><h4 id="本机配置"><a href="#本机配置" class="headerlink" title="本机配置"></a>本机配置</h4><ul><li>master实例，端口6379</li><li>slave1实例，端口20000</li><li>slave2实例，端口20001</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># master配置(/redis_conf/redis-master.conf)，其余默认</span><br><span class="line">bind 127.0.0.1</span><br><span class="line">port 6379</span><br><span class="line"># slave1配置(/redis_conf/redis-slave-20000.conf)，其余默认</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line">port 20000</span><br><span class="line"># slave2配置(/redis_conf/redis-slave-20001.conf)，其余默认</span><br><span class="line">slaveof 127.0.0.1 6379</span><br><span class="line">port 20001</span><br></pre></td></tr></table></figure><p>依次启动master、slave</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server /redis_conf/redis-master.conf</span><br><span class="line">redis-server /redis_conf/redis-slave-20000.conf</span><br><span class="line">redis-server /redis_conf/redis-slave-20001.conf</span><br></pre></td></tr></table></figure><p>输入<code>redis-cli -p 6379</code>进入master的客户端，输入<code>info replication</code>查看从节点，显示如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Replication</span><br><span class="line">role:master</span><br><span class="line">connected_slaves:2</span><br><span class="line">slave0:ip=127.0.0.1,port=20001,state=online,offset=380,lag=0</span><br><span class="line">slave1:ip=127.0.0.1,port=20000,state=online,offset=380,lag=0</span><br><span class="line">master_repl_offset:380</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:379</span><br></pre></td></tr></table></figure><p>主节点写入一个key-value就能在两个从节点中get到</p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><blockquote><p>主从机制，上面的方案中主服务器可能存在单点故障，万一主服务器宕机，这是个麻烦事情，所以Redis提供了Redis-Sentinel，以此来实现主从切换的功能，类似与zookeeper。</p><p>Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-Sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。</p><p>它的主要功能有以下几点</p><ul><li>监控（Monitoring）：不断地检查redis的主服务器和从服务器是否运作正常。</li><li>提醒（Notification）：如果发现某个redis服务器运行出现状况，可以通过 API 向管理员或者其他应用程序发送通知。</li><li>自动故障迁移（Automatic failover）：能够进行自动切换。当一个主服务器不能正常工作时，会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器； 当客户端试图连接失效的主服务器时， 集群也会向客户端返回新主服务器的地址， 使得集群可以使用新主服务器代替失效服务器。</li></ul></blockquote><h4 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h4><p>现在运行了三个redis实例，一主两从</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef | grep redis</span><br><span class="line">root       869     1  0 9月11 ?       00:01:34 redis-server 127.0.0.1:20001</span><br><span class="line">root      1181     1  0 9月11 ?       00:01:35 redis-server 127.0.0.1:20000</span><br><span class="line">root     23943 19684  0 10:27 pts/3    00:00:00 redis-server 127.0.0.1:6379</span><br></pre></td></tr></table></figure><p>编写三个配置sentinel配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">port 10000</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6300 2</span><br><span class="line">port 10001</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6300 2</span><br><span class="line">port 10002</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6300 2</span><br></pre></td></tr></table></figure><p>用<code>redis-sentinel {sentinel-conf}</code>运行三个sentinel实例</p><p>然后将端口为6379的master干掉<code>redis-cli -p 6379 shutdown</code></p><p>此时会发现某个slave通过选举晋升为了master</p><p>如端口为20000的slave晋升为了master，查看info</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#Replication</span><br><span class="line">role:master # 角色变为了master</span><br><span class="line">connected_slaves:1</span><br><span class="line">slave0:ip=127.0.0.1,port=20001,state=online,offset=30728,lag=0 #拥有一个端口为20001的slave</span><br><span class="line">master_repl_offset:30728</span><br><span class="line">repl_backlog_active:1</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:2</span><br><span class="line">repl_backlog_histlen:30727</span><br></pre></td></tr></table></figure><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://juejin.im/post/5b76e732f265da4376203849" target="_blank" rel="noopener">https://juejin.im/post/5b76e732f265da4376203849</a></p><p><a href="https://juejin.im/post/5b7d226a6fb9a01a1e01ff64" target="_blank" rel="noopener">https://juejin.im/post/5b7d226a6fb9a01a1e01ff64</a></p><p><a href="http://blog.720ui.com/2016/redis_action_04_cluster/" target="_blank" rel="noopener">http://blog.720ui.com/2016/redis_action_04_cluster/</a></p><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring相关注解笔记</title>
      <link href="/2019/11/02/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/11/02/Spring%E7%9B%B8%E5%85%B3%E6%B3%A8%E8%A7%A3%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>整理spring注解~</p><a id="more"></a><h1 id="Autowired"><a href="#Autowired" class="headerlink" title="@Autowired"></a>@Autowired</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.CONSTRUCTOR, ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Autowired &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Declares whether the annotated dependency is required.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;Defaults to &#123;<span class="doctag">@code</span> true&#125;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">boolean</span> <span class="title">required</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动注入bean；</p><p>@Autowired(required = false)表示即使被修饰的bean无法被注入，也不会报错；否则spring容器不会运行起来</p><h1 id="Qualifier"><a href="#Qualifier" class="headerlink" title="@Qualifier"></a>@Qualifier</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.METHOD, ElementType.PARAMETER, ElementType.TYPE, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Qualifier &#123;</span><br><span class="line"></span><br><span class="line">   <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 @Qualifier 注释指定注入 Bean 的名称，防止容器中有多个名字相同的bean导致@Autowired注入引起歧义。</p><ol><li>value，对应被注入的bean的名字</li></ol><h1 id="AliasFor"><a href="#AliasFor" class="headerlink" title="@AliasFor"></a>@AliasFor</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AliasFor &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Alias for &#123;<span class="doctag">@link</span> #attribute&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Intended to be used instead of &#123;<span class="doctag">@link</span> #attribute&#125; when &#123;<span class="doctag">@link</span> #annotation&#125;</span></span><br><span class="line"><span class="comment"> * is not declared &amp;mdash; for example: &#123;<span class="doctag">@code</span> <span class="doctag">@AliasFor</span>("value")&#125; instead of</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> <span class="doctag">@AliasFor</span>(attribute = "value")&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"attribute"</span>)</span><br><span class="line"><span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The name of the attribute that &lt;em&gt;this&lt;/em&gt; attribute is an alias for.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AliasFor</span>(<span class="string">"value"</span>)</span><br><span class="line"><span class="function">String <span class="title">attribute</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The type of annotation in which the aliased &#123;<span class="doctag">@link</span> #attribute&#125; is declared.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Defaults to &#123;<span class="doctag">@link</span> Annotation&#125;, implying that the aliased attribute is</span></span><br><span class="line"><span class="comment"> * declared in the same annotation as &lt;em&gt;this&lt;/em&gt; attribute.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;? extends Annotation&gt; annotation() <span class="keyword">default</span> Annotation<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用来声明属性的别名</p><h1 id="Schedule"><a href="#Schedule" class="headerlink" title="@Schedule"></a>@Schedule</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(Schedules<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">Scheduled</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A cron-like expression, extending the usual UN*X definition to include triggers</span></span><br><span class="line"><span class="comment">    * on the second as well as minute, hour, day of month, month and day of week.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;E.g. &#123;<span class="doctag">@code</span> "0 * * * * MON-FRI"&#125; means once per minute on weekdays</span></span><br><span class="line"><span class="comment">    * (at the top of the minute - the 0th second).</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> an expression that can be parsed to a cron schedule</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> org.springframework.scheduling.support.CronSequenceGenerator</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">cron</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A time zone for which the cron expression will be resolved. By default, this</span></span><br><span class="line"><span class="comment">    * attribute is the empty String (i.e. the server's local time zone will be used).</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a zone id accepted by &#123;<span class="doctag">@link</span> java.util.TimeZone#getTimeZone(String)&#125;,</span></span><br><span class="line"><span class="comment">    * or an empty String to indicate the server's default time zone</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 4.0</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> org.springframework.scheduling.support.CronTrigger#CronTrigger(String, java.util.TimeZone)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> java.util.TimeZone</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">zone</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Execute the annotated method with a fixed period in milliseconds between the</span></span><br><span class="line"><span class="comment">    * end of the last invocation and the start of the next.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the delay in milliseconds</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">long</span> <span class="title">fixedDelay</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Execute the annotated method with a fixed period in milliseconds between the</span></span><br><span class="line"><span class="comment">    * end of the last invocation and the start of the next.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the delay in milliseconds as a String value, e.g. a placeholder</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 3.2.2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">fixedDelayString</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Execute the annotated method with a fixed period in milliseconds between</span></span><br><span class="line"><span class="comment">    * invocations.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the period in milliseconds</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">long</span> <span class="title">fixedRate</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Execute the annotated method with a fixed period in milliseconds between</span></span><br><span class="line"><span class="comment">    * invocations.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the period in milliseconds as a String value, e.g. a placeholder</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 3.2.2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">fixedRateString</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Number of milliseconds to delay before the first execution of a</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #fixedRate()&#125; or &#123;<span class="doctag">@link</span> #fixedDelay()&#125; task.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the initial delay in milliseconds</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 3.2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">long</span> <span class="title">initialDelay</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Number of milliseconds to delay before the first execution of a</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> #fixedRate()&#125; or &#123;<span class="doctag">@link</span> #fixedDelay()&#125; task.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the initial delay in milliseconds as a String value, e.g. a placeholder</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 3.2.2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">initialDelayString</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被@Schedule修饰的方法会按照相应的参数定时执行</p><ol><li>cron表达式</li><li>zone，cron表达式对应的时区，默认是本地服务器的时区</li><li>fixedDelay，在最后一次调用结束和下一次调用开始之间以固定周期（以毫秒为单位）执行带注释的方法，ps：类似于串行执行，只不过中间有一个固定的delay。</li><li>fixedDelayString</li><li>fixedRate，不同于fixedDelay，方法之间的调用总是会以固定的周期调用，不管上一个方法结束与否</li><li>fixedRateString</li><li>initialDelay，第一次调用方法之前delay的时间</li><li>initialDelayString</li></ol><h2 id="Spring如何实现-Schedule"><a href="#Spring如何实现-Schedule" class="headerlink" title="Spring如何实现@Schedule"></a>Spring如何实现@Schedule</h2><ol><li>首先需要开启<code>@EnableScheduling</code>注解，开启该注解后Spring会在配置类<code>SchedulingConfiguration</code>中自动注入<code>ScheduledAnnotationBeanPostProcessor</code></li><li><code>ScheduledAnnotationBeanPostProcessor</code>类中会将被<code>@Scheduled</code>修饰的方法注册到<code>ScheduledTaskRegistrar</code>中，同时注入默认的线程池<code>DEFAULT_TASK_SCHEDULER_BEAN_NAME</code>（这个线程池的配置可以自己通过实现接口<code>SchedulingConfigurer</code>来自定义），<strong>默认的线程池是单线程的</strong>。方法会根据注解中给定的参数在线程池中执行</li></ol><h1 id="Async"><a href="#Async" class="headerlink" title="@Async"></a>@Async</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Async &#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * A qualifier value for the specified asynchronous operation(s).</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;May be used to determine the target executor to be used when executing this</span></span><br><span class="line"><span class="comment">    * method, matching the qualifier value (or the bean name) of a specific</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> java.util.concurrent.Executor Executor&#125; or</span></span><br><span class="line"><span class="comment">    * &#123;<span class="doctag">@link</span> org.springframework.core.task.TaskExecutor TaskExecutor&#125;</span></span><br><span class="line"><span class="comment">    * bean definition.</span></span><br><span class="line"><span class="comment">    * &lt;p&gt;When specified on a class level &#123;<span class="doctag">@code</span> <span class="doctag">@Async</span>&#125; annotation, indicates that the</span></span><br><span class="line"><span class="comment">    * given executor should be used for all methods within the class. Method level use</span></span><br><span class="line"><span class="comment">    * of &#123;<span class="doctag">@code</span> Async#value&#125; always overrides any value set at the class level.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@since</span> 3.1.2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注释作用于方法上，被修饰的方法会以异步的方式执行。</p><ol><li>value，对应执行该方法的线程池名字，默认springboot会去匹配Executor或TaskExecutor</li></ol><p>被修饰的方法可以存在方法参数，可以有返回值（<code>Future</code>AND<code>CompletableFuture</code>）</p><p><strong>NOTE：该注解不能同时与@PostConstruct一起使用，但是可以再@PostConstruct中调用被@Async修饰的方法</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Async` can not be used in conjunction with lifecycle callbacks such as `@PostConstruct</span><br></pre></td></tr></table></figure></blockquote><h1 id="PostConstruct"><a href="#PostConstruct" class="headerlink" title="@PostConstruct"></a>@PostConstruct</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span> (RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(METHOD)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> PostConstruct &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该注释只能作用于方法上，该方法会被执行在对应的类依赖注入完成之后。一般用于初始化操作，如读取相应的缓存等</p><h1 id="Retryable"><a href="#Retryable" class="headerlink" title="@Retryable"></a>@Retryable</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123; ElementType.METHOD, ElementType.TYPE &#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Retryable &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Retry interceptor bean name to be applied for retryable method. Is mutually</span></span><br><span class="line"><span class="comment"> * exclusive with other attributes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the retry interceptor bean name</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">interceptor</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exception types that are retryable. Synonym for includes(). Defaults to empty (and</span></span><br><span class="line"><span class="comment"> * if excludes is also empty all exceptions are retried).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> exception types to retry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;? extends Throwable&gt;[] value() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exception types that are retryable. Defaults to empty (and if excludes is also</span></span><br><span class="line"><span class="comment"> * empty all exceptions are retried).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> exception types to retry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;? extends Throwable&gt;[] include() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Exception types that are not retryable. Defaults to empty (and if includes is also</span></span><br><span class="line"><span class="comment"> * empty all exceptions are retried).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> exception types to retry</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Class&lt;? extends Throwable&gt;[] exclude() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A unique label for statistics reporting. If not provided the caller may choose to</span></span><br><span class="line"><span class="comment"> * ignore it, or provide a default.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the label for the statistics</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">label</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flag to say that the retry is stateful: i.e. exceptions are re-thrown, but the</span></span><br><span class="line"><span class="comment"> * retry policy is applied with the same policy to subsequent invocations with the</span></span><br><span class="line"><span class="comment"> * same arguments. If false then retryable exceptions are not re-thrown.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> true if retry is stateful, default false</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">stateful</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the maximum number of attempts (including the first failure), defaults to 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxAttempts</span><span class="params">()</span> <span class="keyword">default</span> 3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> an expression evaluated to the maximum number of attempts (including the first failure), defaults to 3</span></span><br><span class="line"><span class="comment"> * Overrides &#123;<span class="doctag">@link</span> #maxAttempts()&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">maxAttemptsExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specify the backoff properties for retrying this operation. The default is a</span></span><br><span class="line"><span class="comment"> * simple &#123;<span class="doctag">@link</span> Backoff&#125; specification with no properties - see it's documentation</span></span><br><span class="line"><span class="comment"> * for defaults.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a backoff specification</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Backoff <span class="title">backoff</span><span class="params">()</span> <span class="keyword">default</span> @<span class="title">Backoff</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Specify an expression to be evaluated after the &#123;<span class="doctag">@code</span> SimpleRetryPolicy.canRetry()&#125;</span></span><br><span class="line"><span class="comment"> * returns true - can be used to conditionally suppress the retry. Only invoked after</span></span><br><span class="line"><span class="comment"> * an exception is thrown. The root object for the evaluation is the last &#123;<span class="doctag">@code</span> Throwable&#125;.</span></span><br><span class="line"><span class="comment"> * Other beans in the context can be referenced.</span></span><br><span class="line"><span class="comment"> * For example:</span></span><br><span class="line"><span class="comment"> * &lt;pre class=code&gt;</span></span><br><span class="line"><span class="comment"> *  &#123;<span class="doctag">@code</span> "message.contains('you can retry this')"&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * and</span></span><br><span class="line"><span class="comment"> * &lt;pre class=code&gt;</span></span><br><span class="line"><span class="comment"> *  &#123;<span class="doctag">@code</span> "<span class="doctag">@someBean</span>.shouldRetry(#root)"&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;/pre&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the expression.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">String <span class="title">exceptionExpression</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO模型及同步异步阻塞非阻塞</title>
      <link href="/2019/11/02/IO%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/"/>
      <url>/2019/11/02/IO%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/</url>
      
        <content type="html"><![CDATA[<p>概念混淆，重新理解</p><a id="more"></a><h1 id="同步、异步、阻塞、非阻塞"><a href="#同步、异步、阻塞、非阻塞" class="headerlink" title="同步、异步、阻塞、非阻塞"></a>同步、异步、阻塞、非阻塞</h1><blockquote><p>In many circumstances they are different names for the same thing, but in some contexts they are quite different. So it depends. Terminology is not applied in a totally consistent way across the whole software industry.</p><p>For example in the classic sockets API, a non-blocking socket is one that simply returns immediately with a special “would block” error message, whereas a blocking socket would have blocked. You have to use a separate function such as <code>select</code> or <code>poll</code> to find out when is a good time to retry.</p><p>But asynchronous sockets (as supported by Windows sockets), or the asynchronous IO pattern used in .NET, are more convenient. You call a method to start an operation, and the framework calls you back when it’s done. Even here, there are basic differences. Asynchronous Win32 sockets “marshal” their results onto a specific GUI thread by passing Window messages, whereas .NET asynchronous IO is free-threaded (you don’t know what thread your callback will be called on).</p><p>So they don’t always mean the same thing. To distil the socket example, we could say:</p><ul><li><p>Blocking and synchronous mean the same thing: you call the API, it hangs up the thread until it has some kind of answer and returns it to you.</p><p>阻塞与同步意味着同一种意思：一个线程调用API，线程被挂起直到它收到一些回复或返回值</p><p>（阻塞更倾向于等待数据输入，同步倾向等待结果）</p></li><li><p>Non-blocking means that if an answer can’t be returned rapidly, the API returns immediately with an error and does nothing else. So there must be some related way to query whether the API is ready to be called (that is, to simulate a wait in an efficient way, to avoid manual polling in a tight loop).</p><p>非阻塞意味着如果返回值不能立即返回，那么被调用的API将会返回一个错误并且什么都不做。因此必须存在一些相关的方法来查询API是否准备好被调用（就是用有效的方式模拟一个等待来避免手动的轮询）</p></li><li><p>Asynchronous means that the API always returns immediately, having started a “background” effort to fulfil your request, so there must be some related way to obtain the result.</p><p>异步意味着API调用会立马返回，但是会在“后台”来处理你的调用，因此必须存在一些相关的方法来获取结果</p></li></ul></blockquote><h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h2 id="IO阻塞"><a href="#IO阻塞" class="headerlink" title="IO阻塞"></a>IO阻塞</h2><p><img src="https://i.loli.net/2019/01/11/5c38516df0249.png" alt="屏幕快照 2019-01-11 下午4.18.36.png"></p><p>进程阻塞于内核等待数据与之后将数据从内核复制到用户空间的这两个时间段</p><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p><img src="https://i.loli.net/2019/01/11/5c38516e2103b.png" alt="pic2"></p><p>进程一直轮询等待内核是否准备好数据，并不会被挂起或沉睡，直到内核通知进程数据准备完毕</p><blockquote><p>这里所谓的“非阻塞”，也是针对调用recvfrom的进程来说的。对于用户来说，如果每次recvfrom发现没准备好，都继续等待，给用户的感受上其实也要算是一种“阻塞”。</p></blockquote><h2 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h2><p><img src="https://i.loli.net/2019/01/11/5c38516e26b74.png" alt="屏幕快照 2019-01-11 下午4.18.13.png"></p><h2 id="信号驱动式IO模型"><a href="#信号驱动式IO模型" class="headerlink" title="信号驱动式IO模型"></a>信号驱动式IO模型</h2><p><img src="https://i.loli.net/2019/01/11/5c38516e1f2fc.png" alt="屏幕快照 2019-01-11 下午4.18.07.png"></p><h2 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h2><p><img src="https://i.loli.net/2019/01/11/5c38516e1fccd.png" alt="屏幕快照 2019-01-11 下午4.18.01.png"></p><h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p><img src="https://i.loli.net/2019/01/11/5c38516e2896d.png" alt="屏幕快照 2019-01-11 下午4.17.55.png"></p><ol><li>同步IO操作导致请求进程阻塞，直到IO完成</li><li>异步IO操作不导致请求阻塞</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://stackoverflow.com/questions/2625493/asynchronous-vs-non-blocking" target="_blank" rel="noopener">https://stackoverflow.com/questions/2625493/asynchronous-vs-non-blocking</a></p><p><a href="http://www.programmr.com/blogs/difference-between-asynchronous-and-non-blocking" target="_blank" rel="noopener">http://www.programmr.com/blogs/difference-between-asynchronous-and-non-blocking</a></p><p>《Unix网络编程》</p><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK9中的String底层改变</title>
      <link href="/2019/11/02/JDK9%E4%B8%AD%E7%9A%84String%E5%BA%95%E5%B1%82%E6%94%B9%E5%8F%98/"/>
      <url>/2019/11/02/JDK9%E4%B8%AD%E7%9A%84String%E5%BA%95%E5%B1%82%E6%94%B9%E5%8F%98/</url>
      
        <content type="html"><![CDATA[<p>在JDK9中String底层存储字符的char数组变成了byte数组，WHY?</p><a id="more"></a><blockquote><p>The problem is, that the vast majority of the strings in applications can be expressed by just one byte using ISO-8859-1/Latin-1 as they contain no special characters. If such strings could be represented with just one byte per character, that would mean only half of the memory would be used to store the String’s characters. Of course, that does not mean that the whole memory consumed by a String object is now only 50% of the original. Not all the memory allocated by strings is used to store the characters.</p><p>应用程序中的绝大多数字符串可以使用一个字节表示，通过ISO-8859-1 / Latin-1编码，因为它们不包含特殊字符。 如果这样的字符串只能用每个字符一个字节表示，那意味着只有一半的内存用于存储字符串的字符。 当然，这并不意味着String对象消耗的整个内存现在只占原始内存的50％。 并非所有由字符串分配的内存都用于存储字符。</p></blockquote><p><strong>each character is two bytes</strong></p><p><strong>each Chinese is two character(four bytes)</strong></p><h1 id="String源码"><a href="#String源码" class="headerlink" title="String源码"></a>String源码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The value is used for character storage.</span><br><span class="line"> *</span><br><span class="line"> * @implNote This field is trusted by the VM, and is a subject to</span><br><span class="line"> * constant folding if String instance is constant. Overwriting this</span><br><span class="line"> * field after construction will cause problems.</span><br><span class="line"> *</span><br><span class="line"> * Additionally, it is marked with &#123;@link Stable&#125; to trust the contents</span><br><span class="line"> * of the array. No other facility in JDK provides this functionality (yet).</span><br><span class="line"> * &#123;@link Stable&#125; is safe here, because value is never null.</span><br><span class="line"> */</span><br><span class="line">@Stable</span><br><span class="line">private final byte[] value;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The identifier of the encoding used to encode the bytes in</span><br><span class="line"> * &#123;@code value&#125;. The supported values in this implementation are</span><br><span class="line"> *</span><br><span class="line"> * LATIN1</span><br><span class="line"> * UTF16</span><br><span class="line"> *</span><br><span class="line"> * @implNote This field is trusted by the VM, and is a subject to</span><br><span class="line"> * constant folding if String instance is constant. Overwriting this</span><br><span class="line"> * field after construction will cause problems.</span><br><span class="line"> */</span><br><span class="line">private final byte coder;</span><br></pre></td></tr></table></figure><p>用了byte数组，并用coder标识使用的哪种字符集（LATIN1、UTF16）</p><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA DEBUG</title>
      <link href="/2019/11/02/IDEA-DEBUG/"/>
      <url>/2019/11/02/IDEA-DEBUG/</url>
      
        <content type="html"><![CDATA[<p>IDEA断点的一些设置</p><a id="more"></a><p><img src="https://i.loli.net/2019/03/01/5c78c9496b585.png" alt="idea debug"></p><h1 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h1><h2 id="Enabled"><a href="#Enabled" class="headerlink" title="Enabled"></a>Enabled</h2><blockquote><p>Deselect to temporarily disable a breakpoint without removing it from the project. Disabled breakpoints will be skipped during the debugging process.</p></blockquote><p>启用禁用。一般不动</p><h2 id="Suspend"><a href="#Suspend" class="headerlink" title="Suspend"></a>Suspend</h2><blockquote><p>Select to pause the program execution when a breakpoint is hit. Suspending an application is useful if you need to obtain logging information or calculate an expression at a certain point without interrupting the program. If you need to create a <em>master</em> breakpoint that will trigger dependent breakpoints when hit, choose not to suspend the program at that breakpoint.</p></blockquote><p>命中断点后暂停程序</p><h3 id="All"><a href="#All" class="headerlink" title="All"></a>All</h3><blockquote><p>all threads will be suspended</p></blockquote><p>DEFAULT</p><h3 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h3><blockquote><p>only the thread containing this breakpoint will be suspended. If you want the Thread policy to be used as the default one, click the Make default button.</p></blockquote><p>如果想要在多线程中debug每个线程，可以设置该属性。每个包含了该断点的线程都会在此暂停，你可以选择相应的Frames来执行相应的线程，以此控制线程执行的顺序</p><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><blockquote><p>Select to specify a condition for hitting a breakpoint. A condition is a Java Boolean expression including a method returning <code>true</code> or <code>false</code>, for example, <code>str1.equals(str2)</code>.This expression must be valid at the line where the breakpoint is set, and it is evaluated each time the breakpoint is hit.If the evaluation result is <code>true</code>, the selected actions are performed.</p></blockquote><p>给命中断点带上特定的条件。传入的条件需要时Java的布尔表达式</p><h2 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h2><blockquote><p>Select if you want to log the following events to console:</p></blockquote><h3 id="Breakpoint-hit"><a href="#Breakpoint-hit" class="headerlink" title="Breakpoint hit"></a>Breakpoint hit</h3><p>命中断点后打日志</p><h3 id="Stack-trace"><a href="#Stack-trace" class="headerlink" title="Stack trace"></a>Stack trace</h3><p>命中断点后打堆栈日志</p><h2 id="Pass-count"><a href="#Pass-count" class="headerlink" title="Pass count"></a>Pass count</h2><blockquote><p>Select if you need a breakpoint to be triggered only after it has been hit a certain number of times. This is useful for debugging loops or methods called several times.</p><p>NOTE: If both the Pass Count and a Condition are set, IntelliJ IDEA first satisfies the condition, and then checks for pass count to avoid conflicts between the two settings.</p></blockquote><p>命中指定次数的断点后才会暂停程序。</p><p>如果同时设置了Condition，IDEA 优先匹配Condition，然后再判断Pass count</p><h2 id="Evaluate-and-Log"><a href="#Evaluate-and-Log" class="headerlink" title="Evaluate and Log"></a>Evaluate and Log</h2><blockquote><p>Select to evaluate an expression when the breakpoint is hit, and show the result in the console output.</p></blockquote><h2 id="Remove-once-hit"><a href="#Remove-once-hit" class="headerlink" title="Remove once hit"></a>Remove once hit</h2><blockquote><p>Select to remove the breakpoint from your project right after it has been hit.</p></blockquote><h2 id="Disable-until-breakpoint-is-hit"><a href="#Disable-until-breakpoint-is-hit" class="headerlink" title="Disable until breakpoint is hit"></a>Disable until breakpoint is hit</h2><blockquote><p>Select the breakpoint that will trigger the current breakpoint. Until that breakpoint is hit, the current breakpoint will be disabled. You can also select if you wish to disable it again or leave it enabled once it has been hit.</p></blockquote><h2 id="Instance-filters"><a href="#Instance-filters" class="headerlink" title="Instance filters"></a>Instance filters</h2><blockquote><p>Select to limit breakpoint hits with particular object instances. Enter instance IDs separated by spaces, or click <img src="https://www.jetbrains.com/help/img/idea/2018.3/icons.general.openDisk.svg@2x.png" alt="browse"> and add them in the Instance Filters dialog.</p></blockquote><p>选择命中特定对象实例的断点。</p><h2 id="Class-filters"><a href="#Class-filters" class="headerlink" title="Class filters"></a>Class filters</h2><blockquote><p>Select to filter classes where the breakpoint must be hit. Either type in the filters, or click <img src="https://www.jetbrains.com/help/img/idea/2018.3/icons.general.openDisk.svg@2x.png" alt="browse"> and configure filters in the Class Filters dialog.You can specify class names or class patterns (strings with the * wildcard). If a filter is specified through a class name, it points at the class itself and all its subclasses. A filter specified through a class pattern points at classes whose fully qualified names match this pattern.</p></blockquote><p>选择命中特定的类。可以使用*匹配模式</p><h2 id="Caller-filters"><a href="#Caller-filters" class="headerlink" title="Caller filters"></a>Caller filters</h2><blockquote><p>Select if you need to stop at a breakpoint only when it is called (or NOT called) from a certain method. Either type in the caller methods, or click and configure filters in the</p><p>Caller Filters dialog.</p><p>You can specify method names or method patterns (strings with the * wildcard).</p></blockquote><p>选择是否只有在某个方法调用（或未调用）时才需要在断点处停止。</p><h1 id="Watches"><a href="#Watches" class="headerlink" title="Watches"></a>Watches</h1><p>可以在watches里动态的改变变量或表达式的值</p><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> idea </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML转PDF解决方案</title>
      <link href="/2019/11/02/HTML%E8%BD%ACPDF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2019/11/02/HTML%E8%BD%ACPDF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>前阵子公司有个小需求，将HTML转成PDF。前期做了调研，虽然最后没用到，还是留个记录吧</p><a id="more"></a><h2 id="第三方服务"><a href="#第三方服务" class="headerlink" title="第三方服务"></a>第三方服务</h2><h3 id="PDFSHIFT"><a href="#PDFSHIFT" class="headerlink" title="PDFSHIFT"></a>PDFSHIFT</h3><p><a href="https://pdfshift.io/?tab=java" target="_blank" rel="noopener">https://pdfshift.io/?tab=java</a></p><p>优点</p><ol><li>非常简单，以POST的方式就能将指定url生成为pdf</li><li>转换效果非常棒</li></ol><p>缺点</p><ol><li>每个月每个免费的KEY只能转化250次，之后需要收费</li><li>转化的pdf大小要在1M之内</li><li>网上资料几乎没有，只有官方文档</li></ol><h3 id="Convertio"><a href="#Convertio" class="headerlink" title="Convertio"></a>Convertio</h3><p><a href="https://convertio.co/zh/" target="_blank" rel="noopener">https://convertio.co/zh/</a></p><p>优点</p><ol><li>简单，也是以POST请求的方式</li><li>文档丰富 <a href="https://developers.convertio.co/api/docs/" target="_blank" rel="noopener">https://developers.convertio.co/api/docs/</a></li></ol><p>缺点</p><ol><li>没有PDFSHIFT转换的效果好</li><li>免费的版本有转换限制：a daily limit of 25 conversion minutes.</li></ol><p><strong>同一页面的转换对比：</strong></p><p>PDFSHIFT</p><p><img src="https://cnhkblog.top/Users/qianhangkang/Library/Application%20Support/typora-user-images/image-20190124110502754.png" alt="image-20190124110502754"></p><p>Convertio</p><p><img src="https://cnhkblog.top/Users/qianhangkang/Library/Application%20Support/typora-user-images/image-20190124110610554.png" alt="image-20190124110610554"></p><h2 id="开源解决方案"><a href="#开源解决方案" class="headerlink" title="开源解决方案"></a>开源解决方案</h2><h3 id="Flying-Saucer"><a href="#Flying-Saucer" class="headerlink" title="Flying-Saucer"></a>Flying-Saucer</h3><p><a href="https://github.com/flyingsaucerproject/flyingsaucer" target="_blank" rel="noopener">https://github.com/flyingsaucerproject/flyingsaucer</a></p><p>优势</p><ol><li>一个解决方案</li></ol><p>缺点</p><ol><li>对HTML格式要求严格，每个标签必须有对应的结束标签</li><li>中文字体需要手动加载相应字体</li></ol><h3 id="wkhtmltopdf"><a href="#wkhtmltopdf" class="headerlink" title="wkhtmltopdf"></a>wkhtmltopdf</h3><p><a href="https://wkhtmltopdf.org/downloads.html" target="_blank" rel="noopener">https://wkhtmltopdf.org/downloads.html</a></p><p>使用C写的一个库</p><p>优点</p><ol><li>转换效果非常棒</li><li>文档丰富、功能齐全、支持中文</li><li>支持多平台</li></ol><p>缺点</p><ol><li>在java中使用只能调用相应的命令行</li><li>服务器上可能无法安装对应二进制程序</li></ol><h3 id="WeasyPrint"><a href="#WeasyPrint" class="headerlink" title="WeasyPrint"></a>WeasyPrint</h3><p><a href="https://weasyprint.org/" target="_blank" rel="noopener">https://weasyprint.org/</a></p><p>使用python写的库</p><p>优点</p><ol><li>转换效果一般</li></ol><p>缺点</p><ol><li>在java中使用只能调用相应的命令行</li><li>服务器上可能无法安装对应二进制程序</li></ol><h3 id="ITEXT7"><a href="#ITEXT7" class="headerlink" title="ITEXT7"></a>ITEXT7</h3><p>老牌解决方案</p><p>缺点</p><ol><li>商业使用需要收费</li><li>中文支持需要手动导入</li></ol><h3 id="pdf2htmlEX"><a href="#pdf2htmlEX" class="headerlink" title="pdf2htmlEX"></a><strong>pdf2htmlEX</strong></h3><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>关于git的一些问题</title>
      <link href="/2019/11/02/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
      <url>/2019/11/02/%E5%85%B3%E4%BA%8Egit%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>微小工具叫 git <del>。</del></p><a id="more"></a><p>在本地有一个提交了很久的master分支，没有维护到远程服务器，突然想起github的私有仓库已经免费，于是准备提交到服务器上。</p><p>OK，在github上创建了一个repository，在网页上初始化了一个README文件，远程master分支有了第一次的initial commit。</p><p>在自己本地文件夹下添加远程库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:&lt;your account&gt;/&lt;your repository&gt;.git</span><br></pre></td></tr></table></figure><p>没有输出，成功添加远程库。</p><p>习惯性<code>git pull</code></p><p>控制台回显如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">warning: no common commits</span><br><span class="line">remote: Enumerating objects: 3, done.</span><br><span class="line">remote: Counting objects: 100% (3/3), done.</span><br><span class="line">remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), done.</span><br><span class="line">From github.com:&lt;your account&gt;/&lt;your repository&gt;</span><br><span class="line"> * [new branch]      master     -&gt; origin/master</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; master</span><br></pre></td></tr></table></figure><p>OK，git好像不知道本地master与origin/master的关联关系</p><p>执行<code>git branch --set-upstream-to=origin/&lt;branch填你自己远程的branch哦~&gt; master</code></p><p>没有输出，成功关联本地master与远程master</p><p>再执行<code>git pull</code></p><p>控制台回显如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: refusing to merge unrelated histories</span><br></pre></td></tr></table></figure><p>嗷，fatal，拒绝merge不相关的历史</p><p>也是，远程master的提交记录只有initial commit，而我本地分支却有一长串自己的提交，git认为这是两个不同的项目，无法提交。</p><p>那就强制合并</p><p>执行<code>git pull origin master --allow-unrelated-histories</code></p><p>将远程master pull到本地master，允许不相关历史的merge</p><p>没有输出，成功merge</p><p>此时输入<code>git log</code>，可以看到远程master的提交已经合并打本地分支</p><p><code>git push</code>大功告成~</p><h1 id="如何删除本地未追踪的文件"><a href="#如何删除本地未追踪的文件" class="headerlink" title="如何删除本地未追踪的文件"></a>如何删除本地未追踪的文件</h1><p><code>git clean -fd</code>将未追踪的文件和目录都删除</p><blockquote><p> 大部分正义感都是虚伪的 聊胜于无 —————————————沃德彭尤·胡某</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>review JVM</title>
      <link href="/2018/07/22/review-JVM/"/>
      <url>/2018/07/22/review-JVM/</url>
      
        <content type="html"><![CDATA[<p>复习下关于JVM的知识<del>~</del></p><a id="more"></a><p>##介绍下Java内存区域（运行时数据区）。</p><p>JVM运行时数据区分为方法区、堆内存、虚拟机栈、本地方法栈、程序计数器这五个部分。方法区和堆内存是线程共享的，其他三个区域是线程私有的，其中只有程序计数器没有规定OOM的异常。</p><ul><li>方法区一般存放着已被虚拟机加载的类信息、常量、静态变量、及时编译器编译后的代码数据等。</li><li>堆内存一般用于存储实例化后的对象，通常来说又分为新生代和老年代。新生代又分为Eden区和survivor区，他们的大小比例默认为8：2，可以通过-XX:survivorRatio来自定义。对象一般都是在新生代分配内存空间，而老年代一般存放着长期存活或者占用内存较大的对象。</li><li>虚拟机栈通常存放着指向实例对象的引用、局部变量、方法返回地址、动态链接等信息，其生命周期和线程相同。如果栈请求的深度超过了虚拟机所允许的最大深度，此时JVM会抛出StackOverflowError；如果扩展时无法分配到足够的内存，会抛出OOM</li><li>本地方法栈和虚拟机栈类似，不过本地方法栈是为JVM执行本地方法服务的，该区域也会抛出栈溢出和内存溢出的异常。</li><li>程序计数器的作用是为了线程切换后能够恢复到正确的执行位置，不过如果执行的是native方法，对应的程序计数器是为空的</li></ul><h2 id="对象的访问定位的两种方式。"><a href="#对象的访问定位的两种方式。" class="headerlink" title="对象的访问定位的两种方式。"></a>对象的访问定位的两种方式。</h2><ol><li><strong>通过句柄访问，句柄中存储着对象实例数据和类型数据的地址，此时堆内存中需要维护一个句柄池</strong></li></ol><p>使用句柄最大的好处就是移动对象时，reference不需要改变， 改变的只是句柄中的对象地址；</p><ol start="2"><li>通过指针访问，此时引用中存储的就是对象的地址</li></ol><p>而指针的最大好处就是速度更快</p><h2 id="如何判断对象是否死亡（两种方法）。"><a href="#如何判断对象是否死亡（两种方法）。" class="headerlink" title="如何判断对象是否死亡（两种方法）。"></a>如何判断对象是否死亡（两种方法）。</h2><ol><li><p>引用计数法。</p><p>引用计数法简单高效，当一个对象被引用时其引用计数器就+1，但是这不能解决循环引用的问题。比如类A中的字段引用了类B，类B中也有个字段引用了类A，那么这两个类的对象就永远不会被回收。</p></li><li><p>可达性分析，也就是分析GC Roots的引用链</p><p>如果对象在GC Roots中不可达、没有引用链，那么说明这个对象是不可用的，可以被垃圾回收的。</p><p><strong>可做GC Roots的对象</strong></p><ul><li>虚拟机栈中所引用的对象</li><li>本地方法栈中所引用的对象</li><li>类中的静态属性所引用的对象</li><li>方法区常量引用的对象</li></ul></li></ol><h2 id="简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。"><a href="#简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。" class="headerlink" title="简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。"></a>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</h2><ol><li><p>强引用：一般是new出来对象的引用，只要存在，就不会被回收</p></li><li><p>软引用：一般是用来描述可用但又不是必须的对象</p></li><li><p>弱引用：用来描述非必须的对象，会在垃圾回收的被回收</p></li><li><p>虚引用：是一种最弱的引用关系，唯一的目的是让这个对象在垃圾回收的时候收到一个系统通知</p></li></ol><h2 id="垃圾收集有哪些算法，各自的特点？"><a href="#垃圾收集有哪些算法，各自的特点？" class="headerlink" title="垃圾收集有哪些算法，各自的特点？"></a>垃圾收集有哪些算法，各自的特点？</h2><p>垃圾回收目前有四种算法分别为标记-清除、复制算法、标记-整理、分代收集算法</p><ol><li>标记-清理：存在效率问题和空间问题，清理完后内存中会产生大量不连续的空间碎片，影响下次对象的分配，可能导致提前触发GC</li><li>复制算法：实现简单，效率高效，但可能会造成内存空间的浪费</li><li>标记-整理：每次标记完可回收对象，让<strong>存活的对象向一端移动</strong>，然后直接清理掉边界以外的内存。这个算法就解决了标记-清理算法的空间问题</li><li>分代收集：根据各自区域的特点使用不同的回收算法。如年轻代，对象一般朝生夕死，所以会采用复制算法，而老年代对象存活时间较久，一般采用标记-整理算法，这样也能保证老年代中有连续较大的内存空间，方便分配担保</li></ol><h2 id="HotSpot为什么要分为新生代和老年代？"><a href="#HotSpot为什么要分为新生代和老年代？" class="headerlink" title="HotSpot为什么要分为新生代和老年代？"></a>HotSpot为什么要分为新生代和老年代？</h2><p>为了方便垃圾回收时使用对应的回收算法。年轻代中对象一般刚创建后就会被回收，此时采用复制算法只需要复制少量对象，效率高，但是这并不适用老年代中存活交久的对象，当复制较多对象时，复制算法的效率就会很低，此时采用标记-整理的算法更加适合老年代。</p><h2 id="常见的垃圾回收器有那些？"><a href="#常见的垃圾回收器有那些？" class="headerlink" title="常见的垃圾回收器有那些？"></a>常见的垃圾回收器有那些？</h2><ol><li>Serial串行收集器：这是一个单进程的、适用于新生代的收集器，采用复制算法，每次回收的时候需要暂停其他的工作线程，也就是需要 STOP THE WORLD。</li><li>ParNew收集器：是Serial收集器的多线程版本，也是采用复制算法，目前只有他能与CMS收集器一起工作</li><li>Parallel Scavenge收集器：是一个并行的、新生代的收集器，采用复制算法，他的特点是达到一个可控制的吞吐量</li><li>CMS收集器：是一款真正意思上的并行的、老年代的收集器，采用了标记-清理算法。</li><li>Serial Old 收集器：是Serial收集器的老年代版本，采用标记-整理算法。</li><li>Parallel Old收集器：是Parallel Scavenge的老年代版本，采用标记-整理算法。</li><li>G1收集器：</li></ol><h2 id="介绍一下CMS-G1收集器。"><a href="#介绍一下CMS-G1收集器。" class="headerlink" title="介绍一下CMS,G1收集器。"></a>介绍一下CMS,G1收集器。</h2><p><em>CMS</em></p><p>是一款真正意思上的并行的、老年代的收集器，特点是并发收集、低停顿。采用了标记-清理算法。收集分为四个过程</p><ol><li>初始标记：标记没有关联在GC Roots引用链上的对象</li><li>并发标记：GC Roots Tracing的过程</li><li>重新标记：修正并发标记期间用户线程继续运行而导致的标记的变动</li><li>并发清理：把标记的对象回收</li></ol><p>但是也有三个明显的缺点：</p><ol><li>对CPU资源非常敏感</li><li>无法处理浮动垃圾</li><li>因为基于标记-清理算法，因此会产生大量的不连续的空间。不过可以通过开启一个参数让他在Full GC之前进行一次内存整理</li></ol><p><em>G1</em></p><p><a href="https://tech.meituan.com/g1.html" target="_blank" rel="noopener">美团技术团队的分析</a></p><p><a href="http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" target="_blank" rel="noopener">ifeve解析</a></p><h2 id="Minor-GC和Full-GC-有什么不同呢？"><a href="#Minor-GC和Full-GC-有什么不同呢？" class="headerlink" title="Minor GC和Full GC 有什么不同呢？"></a>Minor GC和Full GC 有什么不同呢？</h2><ul><li>Minor GC是发生在年轻代的GC，发生频率高，回收速度快</li><li>Full GC发生在老年代的GC，发生的时候一般伴随着一次Minor GC，速度较慢，一般是比Minor GC慢十倍</li></ul><h2 id="JVM调优的常见命令行工具有哪些？"><a href="#JVM调优的常见命令行工具有哪些？" class="headerlink" title="JVM调优的常见命令行工具有哪些？"></a>JVM调优的常见命令行工具有哪些？</h2><p>Linux：top、iostat、pidstat、uptime</p><p>Java自带：jstack、jinfo、jstat</p><p>##简单介绍一下Class类文件结构（常量池主要存放的是那两大常量？Class文件的继承关系是如何确定的？字段表、方法表、属性表主要包含那些信息？）</p><ol><li><p>常量池一般存放符号引用和字面量</p><ul><li><p>字面量：一般指文本字符串、声明为final的常量</p></li><li><p>符号引用：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符</li></ul></li></ul></li></ol><ol start="2"><li><p>类索引、父类索引和接口索引集合确定了Class文件的继承关系</p></li><li><ul><li>字段表用于描述类或接口中声明的变量</li><li>方法表的结构与字段表一样</li><li>属性表包含了类文件或者接口所定义的属性的基本信息</li></ul></li></ol><h2 id="简单说说类加载过程，里面执行了哪些操作？"><a href="#简单说说类加载过程，里面执行了哪些操作？" class="headerlink" title="简单说说类加载过程，里面执行了哪些操作？"></a>简单说说类加载过程，里面执行了哪些操作？</h2><p>类加载一般分为七个过程：</p><ol><li>加载<ul><li>通过一个类的全限定名来加载对应的二进制流</li><li>将这个二进制流代表的静待存储结构转化为方法区的运行时数据结构</li><li>在Java堆中生成一个Class对象作为方法区访问这些数据的入口</li></ul></li><li>验证<ul><li>一般完成四个阶段的验证<ol><li>文件格式验证：验证二进制流符合虚拟机的要求，比如前四个字节为cafebaby，第五第六个字节为次版本号，第七第八个字节为主版本号</li><li>元数据验证：就是对类的元数据信息进行语义校验</li><li>字节码验证：对数据流和控制流分析，确保不会危害虚拟机</li><li>符号引用验证：对常量池中的各种符号引用的校验</li></ol></li></ul></li><li>准备<ul><li>对类变量设置初始值的过程，这个初始值是数据类型的默认值，而不是为类变量进行初始化。比如public static int a =3，此时准备阶段只是将int值赋值为0</li></ul></li><li>解析<ul><li>虚拟机将常量池中的符号引用转化为直接引用的过程<ol><li>类或接口的解析</li><li>字段解析</li><li>类方法解析</li><li>接口方法解析</li></ol></li></ul></li><li>初始化<ul><li>此阶段真正开始执行类中定义的Java代码</li></ul></li><li>使用</li><li>卸载</li></ol><h2 id="对类加载器有了解吗？"><a href="#对类加载器有了解吗？" class="headerlink" title="对类加载器有了解吗？"></a>对类加载器有了解吗？</h2><p>类加载器是一个代码模块，他的作用是通过类的全限定名来加载对应类的二进制流。类加载器分为三类：</p><ul><li><p>启动类加载器</p><p>加载JAVA_HOME/lib目录下的类</p></li><li><p>扩展类加载器</p><p>加载JAVA_HOME/lib/ext目录下的类</p></li><li><p>应用程序扩展类</p><p>一般用于加载用户路径上所指定的类库</p></li></ul><h2 id="什么是双亲委派模型？"><a href="#什么是双亲委派模型？" class="headerlink" title="什么是双亲委派模型？"></a>什么是双亲委派模型？</h2><p>双亲委派模型就是除了顶层的启动类加载器外，其余的加载器都应当有自己的父类加载器，是一种类加载器的关系模型。</p><h2 id="双亲委派模型的工作过程以及使用它的好处。"><a href="#双亲委派模型的工作过程以及使用它的好处。" class="headerlink" title="双亲委派模型的工作过程以及使用它的好处。"></a>双亲委派模型的工作过程以及使用它的好处。</h2><ol><li><p>工作过程</p><p>一个类加载器收到类的加载请求，会将请求委托给父类加载器，每层加载器都是如此，直到委托给启动类加载器，如果父类加载器反馈无法加载，那么子加载器才会尝试自己加载</p></li><li><p>好处</p><p>Java类随着它的类加载器有了一种带优先级的层级关系。比如你自己建了一个Object类与Java自带的Object类重名了，虽然可以正常编译，但是永远无法被加载运行。这样就保证了代码的稳定性。</p></li></ol><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络相关知识整理</title>
      <link href="/2018/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/"/>
      <url>/2018/06/19/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>整理下基础的计算机网络。</p><a id="more"></a><h1 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h1><p><img src="https://i.loli.net/2018/06/21/5b2b202fee6d5.png" alt="network.png"></p><h3 id="1-五层协议"><a href="#1-五层协议" class="headerlink" title="1. 五层协议"></a>1. 五层协议</h3><ul><li><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。</li><li><strong>运输层</strong> ：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</li><li><strong>网络层</strong> ：为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。</li><li><strong>数据链路层</strong> ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的节点提供服务。数据链路层把网络层传来的分组封装成帧。</li><li><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h3 id="2-七层协议"><a href="#2-七层协议" class="headerlink" title="2. 七层协议"></a>2. 七层协议</h3><p>其中表示层和会话层用途如下：</p><ul><li><strong>表示层</strong> ：数据压缩、加密以及数据描述。这使得应用程序不必担心在各台主机中表示/存储的内部格式不同的问题。</li><li><strong>会话层</strong> ：建立及管理会话。</li></ul><p>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><h2 id="超文本传输协议"><a href="#超文本传输协议" class="headerlink" title="超文本传输协议"></a>超文本传输协议</h2><p>HTTP(HyperText Transfer Protocol)是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础。</p><p><em>请求方法</em></p><ol><li>GET</li><li>POST</li><li>PUT</li><li>DELETE</li><li>TRACE</li><li>HEAD</li><li>OPTIONS</li><li>CONNECT</li></ol><p><em>状态码</em></p><ul><li>1xx消息——请求已被服务器接收，继续处理</li><li>2xx成功——请求已成功被服务器接收、理解、并接受</li><li>3xx重定向——需要后续操作才能完成这一请求</li><li>4xx请求错误——请求含有词法错误或者无法被执行</li><li>5xx服务器错误——服务器在处理某个正确请求时发生错误</li></ul><h2 id="超文本传输安全协议"><a href="#超文本传输安全协议" class="headerlink" title="超文本传输安全协议"></a>超文本传输安全协议</h2><p>HTTPS(HyperText Transfer Protocol Secure)是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包</p><h2 id="电子邮件协议"><a href="#电子邮件协议" class="headerlink" title="电子邮件协议"></a>电子邮件协议</h2><p><em>电子邮件系统三部分</em></p><ol><li>用户代理</li><li>邮件服务器</li><li>邮件协议</li></ol><p><em>邮件协议</em></p><ol><li>发送协议<ul><li>SMTP(Simple Mail Transfer Protocol):相对简单的基于文本的协议</li></ul></li><li>接受协议<ul><li>POP3(Post Office Protocol - Version 3):特点是从服务器读取后就会删除邮件</li><li>IMAP(Internet Mail Access Protocol):客户端与服务器保持同步。</li></ul></li></ol><h2 id="动态主机配置协议"><a href="#动态主机配置协议" class="headerlink" title="动态主机配置协议"></a>动态主机配置协议</h2><p>DHCP(Dynamic Host Configuration Protocol)是一个局域网的网络协议，使用UDP协议工作，主要有两个用途</p><ol><li>用于内部网络或网络服务供应商自动分配IP给用户</li><li>用于内部网络管理员作为对所有计算机作中央管理的手段</li></ol><h2 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h2><table><thead><tr><th>应用</th><th>应用层协议</th><th>端口号</th><th>运输层协议</th><th>备注</th></tr></thead><tbody><tr><td>域名解析</td><td>DNS</td><td>53</td><td>UDP/TCP</td><td>长度超过 512 字节时使用 TCP</td></tr><tr><td>动态主机配置协议</td><td>DHCP</td><td>67/68</td><td>UDP</td><td></td></tr><tr><td>简单网络管理协议</td><td>SNMP</td><td>161/162</td><td>UDP</td><td></td></tr><tr><td>文件传送协议</td><td>FTP</td><td>20/21</td><td>TCP</td><td>控制连接 21，数据连接 20</td></tr><tr><td>远程终端协议</td><td>TELNET</td><td>23</td><td>TCP</td><td></td></tr><tr><td>超文本传送协议</td><td>HTTP</td><td>80</td><td>TCP</td><td></td></tr><tr><td>超文本传送安全协议</td><td>HTTPS</td><td>443</td><td>TCP</td><td></td></tr><tr><td>简单邮件传送协议</td><td>SMTP</td><td>25</td><td>TCP</td><td></td></tr><tr><td>邮件读取协议</td><td>POP3</td><td>110</td><td>TCP</td><td></td></tr><tr><td>网际报文存取协议</td><td>IMAP</td><td>143</td><td>TCP</td><td></td></tr></tbody></table><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>UDP(User Datagram Protocol)是一种简单的面向数据报的传输层协议，只提供数据的不可靠的传递。</p><h3 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h3><p><img src="https://i.loli.net/2018/06/21/5b2b052fb28f1.jpg" alt="1.jpg"></p><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP(Transmission Control Protocol)是一种面向连接的、可靠地、基于字节流的传输层通信协议。</p><h3 id="首部格式-1"><a href="#首部格式-1" class="headerlink" title="首部格式"></a>首部格式</h3><p><img src="https://i.loli.net/2018/06/21/5b2b15da98c46.png" alt="2.png"></p><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h3><p><img src="https://i.loli.net/2018/06/21/5b2b1e23169ac.png" alt="3.png"></p><p>假设 A 为客户端，B 为服务器端。</p><ul><li>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。</li><li>A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 x。</li><li>B 收到连接请求报文段，如果同意建立连接，则向 A 发送连接确认报文段，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。</li><li>A 收到 B 的连接确认报文段后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。</li><li>B 收到 A 的确认后，连接建立。</li></ul><p><strong>三次握手的原因</strong></p><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>失效的连接请求是指，客户端发送的连接请求在网络中滞留，客户端因为没及时收到服务器端发送的连接确认，因此就重新发送了连接请求。滞留的连接请求并不是丢失，之后还是会到达服务器。如果不进行第三次握手，那么服务器会误认为客户端重新请求连接，然后打开了连接。但是并不是客户端真正打开这个连接，因此客户端不会给服务器发送数据，这个连接就白白浪费了。</p><h3 id="TCP四次挥手"><a href="#TCP四次挥手" class="headerlink" title="TCP四次挥手"></a>TCP四次挥手</h3><p><img src="https://i.loli.net/2018/06/21/5b2b1e230bada.jpg" alt="4.jpg"></p><p>以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。</p><ul><li>A 发送连接释放报文段，FIN=1。</li><li>B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。</li><li>当 B 不再需要连接时，发送连接释放请求报文段，FIN=1。</li><li>A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL 时间后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><p><strong>四次挥手的原因</strong></p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。</p><h2 id="TCP和UDP的特点"><a href="#TCP和UDP的特点" class="headerlink" title="TCP和UDP的特点"></a>TCP和UDP的特点</h2><ul><li>UDP是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。</li><li>是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</li></ul><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻译：字段注入被认为是有害的</title>
      <link href="/2018/06/06/%E7%BF%BB%E8%AF%91%EF%BC%9A%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%98%AF%E6%9C%89%E5%AE%B3%E7%9A%84/"/>
      <url>/2018/06/06/%E7%BF%BB%E8%AF%91%EF%BC%9A%E5%AD%97%E6%AE%B5%E6%B3%A8%E5%85%A5%E8%A2%AB%E8%AE%A4%E4%B8%BA%E6%98%AF%E6%9C%89%E5%AE%B3%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>平常使用<code>@Autowired</code>时IDEA总是会提醒</p><blockquote><p>field injection is not recommended.<strong>Spring teams recommends</strong>: <em>Always use constructor based dependency injection in your beans. Always use assertions for mandatory dependencies.</em></p></blockquote><p>why……</p><p>本文主要翻译了外国大佬的一篇文章——参考链接第一条</p><a id="more"></a><h1 id="字段注入被认为是有害的"><a href="#字段注入被认为是有害的" class="headerlink" title="字段注入被认为是有害的"></a>字段注入被认为是有害的</h1><p>字段注入是依赖注入框架中非常流行的一种实践，比如Spring。但是，它有几个严重的问题，通常应该避免。</p><h2 id="注入类型"><a href="#注入类型" class="headerlink" title="注入类型"></a>注入类型</h2><p>有三种主要方法可以将你的依赖注入到你的类中。构造函数，Setter（方法）和Field注入。下面我们快速比较下使用这三种方法来注入的相同依赖的代码。</p><h3 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DependencyA dependencyA;</span><br><span class="line"><span class="keyword">private</span> DependencyB dependencyB;</span><br><span class="line"><span class="keyword">private</span> DependencyC dependencyC;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DI</span><span class="params">(DependencyA dependencyA, DependencyB dependencyB, DependencyC dependencyC)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dependencyA = dependencyA;</span><br><span class="line">    <span class="keyword">this</span>.dependencyB = dependencyB;</span><br><span class="line">    <span class="keyword">this</span>.dependencyC = dependencyC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DependencyA dependencyA;</span><br><span class="line"><span class="keyword">private</span> DependencyB dependencyB;</span><br><span class="line"><span class="keyword">private</span> DependencyC dependencyC;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependencyA</span><span class="params">(DependencyA dependencyA)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dependencyA = dependencyA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependencyB</span><span class="params">(DependencyB dependencyB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dependencyB = dependencyB;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDependencyC</span><span class="params">(DependencyC dependencyC)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dependencyC = dependencyC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字段注入"><a href="#字段注入" class="headerlink" title="字段注入"></a>字段注入</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DependencyA dependencyA;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DependencyB dependencyB;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> DependencyC dependencyC;</span><br></pre></td></tr></table></figure><h2 id="哪里不对了？"><a href="#哪里不对了？" class="headerlink" title="哪里不对了？"></a>哪里不对了？</h2><p>正如你所看到的，使用字段注入的方式看起来非常棒。它非常简短，没有 boilerplate code(不重要的但是又不得不写的代码，有点像一个POJO里的getter与setter方法。详见<a href="https://en.wikipedia.org/wiki/Boilerplate_code" target="_blank" rel="noopener">wiki</a>)。该代码易于阅读和导航。你的类可以专注于重要的事情，并且不受 DI(Dependency Injection) boilerplate 的污染。您只需将@Autowired注释放在字段上方即可。这种方式没有特殊的构造函数或setter方法，而这些方法只为了DI容器提供您的依赖关系。Java是非常冗长的，因此欢迎各种缩短代码的机会，对吧？</p><h3 id="违反单一责任原则"><a href="#违反单一责任原则" class="headerlink" title="违反单一责任原则"></a>违反单一责任原则</h3><p>添加新的依赖关系非常简单。也许太容易了。添加六个，十个甚至十几个依赖关系是没有问题的。当你使用DI的构造函数时，在某个点之后，构造函数参数的数量变得太高，并且很明显有些事情是错误的。拥有太多的依赖通常意味着这个类有太多的责任。这可能违反了单一责任原则和关注点分离，并且这是一个很好的指示器，说明该类需要进一步检查和可能的重构。当直接注入字段时没有这样的警示，因为这种方法可以无限缩放。</p><h3 id="依赖隐藏"><a href="#依赖隐藏" class="headerlink" title="依赖隐藏"></a>依赖隐藏</h3><p>使用DI容器意味着类不再负责管理自己的依赖关系。此时获取依赖的责任就是从类中提取。其他人现在负责提供依赖项 - DI容器或在测试中手动分配它们。当类不再负责获取它的依赖关系时，它应该使用公共接口 - 方法或构造函数清楚地传达它们。这样就清楚了类的要求，以及它是可选的(setters)还是强制的(构造函数)。</p><h3 id="DI-容器的耦合"><a href="#DI-容器的耦合" class="headerlink" title="DI 容器的耦合"></a>DI 容器的耦合</h3><p>DI框架的核心思想之一是托管类不应该依赖于所使用的DI容器。换句话说，它应该只是一个普通的POJO，它可以独立实例化，只要您传递所有必需的依赖关系即可。通过这种方式，您可以在单元测试中实例化它，而无需启动DI容器并单独进行测试（使用集成度较高的容器进行集成测试）。如果没有容器耦合，则可以让类用被管理或不被管理，甚至可以切换到新的DI框架。</p><p>但是，当直接注入字段时，这不会提供直接实例化具有所有必需依赖项的类的方法。这意味着：</p><ul><li>有一种方法（通过调用默认构造函数） 在缺少某些强制协作者的情况下使用<em>new</em>创建对象，并且使用将导致NullPointerException。</li><li>这样的类不能在DI容器（测试，其他模块）之外重复使用，因为除<strong>反射</strong>之外没有办法为它提供所需的依赖关系。</li></ul><p>这里引入知乎<a href="https://www.zhihu.com/people/cxfree" target="_blank" rel="noopener">大头菜</a>的一段解释</p><blockquote><p>例如A依赖B, 当想暂时脱离spring容器用mock出来的B测试A时, 实例化A之后注入B, 对于其他两种注入方式很简单, 但如果是字段注入的话, 要通过反射才能注入B.</p></blockquote><h3 id="不变形"><a href="#不变形" class="headerlink" title="不变形"></a>不变形</h3><p>与构造函数不同，字段注入不能用于将依赖关系指定给最终字段，从而有效地将对象渲染为可变的。</p><p>（尼玛，好难理解）</p><h2 id="构造器注入-vs-Setter注入"><a href="#构造器注入-vs-Setter注入" class="headerlink" title="构造器注入 vs Setter注入"></a>构造器注入 vs Setter注入</h2><p>所以字段注射不像是行得通的方法。那么还剩下什么？Setter和构造函数。哪一个应该使用？</p><h3 id="setter注入-1"><a href="#setter注入-1" class="headerlink" title="setter注入"></a>setter注入</h3><p>应使用Setter来注入可选的依赖项。没有提供时，class应该能够运作。对象实例化后，随时可以更改依赖关系。取决于具体情况，这可能不是一个好处。有时需要拥有一个不可变的对象。有时在运行时更改对象的协作者是很好的 - 例如JMX托管的MBean。</p><p><a href="http://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/beans.html#d0e2778" target="_blank" rel="noopener">Spring 3.x文档</a>的官方建议鼓励在构造函数上使用setter：</p><blockquote><p>Spring团队通常主张setter注入，因为大量的构造函数参数可能会变得笨拙，特别是当其中有些参数是可选的时候。Setter方法也使该类的对象可以重新配置或稍后重新注入。通过<a href="http://docs.spring.io/spring/docs/3.1.x/spring-framework-reference/html/jmx.html" target="_blank" rel="noopener">JMX MBeans进行</a>管理是一个引人注目的用例。</p><p>一些纯粹主义者喜欢基于构造函数的注入。提供所有对象依赖性意味着对象总是以完全初始化的状态返回给客户端（调用）代码。缺点是物体变得不适合重新配置和重新注入。</p></blockquote><h3 id="构造器注入-1"><a href="#构造器注入-1" class="headerlink" title="构造器注入"></a>构造器注入</h3><p>构造器注入对于强制性依赖是有利的。那些，这是对象正常运行所必需的。通过在构造函数中提供这些对象，可以确保该对象在构建时即可使用。在构造函数中分配的字段也可以是final，从而允许该对象完全不可变或至少保护其必需的字段。</p><p>使用构造函数提供依赖关系的一个后果是，以这种方式构造的两个对象之间的循环依赖变得不可能（与setter注入不同）。这实际上是一件好事，而不是限制，因为应该避免循环依赖，循环依赖通常来说是坏设计的标志。这样可以防止这种做法。</p><p>另一个优点是，如果使用spring 4.3+，则可以将您的类与DI框架完全分离。原因是Spring现在支持一个构造函数场景的<a href="https://spring.io/blog/2016/03/04/core-container-refinements-in-spring-framework-4-3" target="_blank" rel="noopener">隐式构造函数注入</a>（类似上面的构造器注入）。这意味着你不再需要在你的类中使用DI注解。当然，你可以通过在给定类的spring配置文件中明确配置DI来达到同样的效果，这只会让这一切变得更容易。</p><p>从Spring 4.x开始，官方的<a href="http://docs.spring.io/spring/docs/4.2.x/spring-framework-reference/html/beans.html#beans-constructor-injection" target="_blank" rel="noopener">Spring文档</a>更改了，setter注入的建议不再被官方提倡，取而代之的是构造器注入：</p><blockquote><p>Spring团队通常提倡构造器注入，因为它使得可以将应用程序组件实现为<em>不可变对象，</em>并确保所需的依赖项不为空。此外，构造器注入的组件总是返回到处于完全初始化状态的客户端（调用）代码。作为一个侧面说明，大量的构造函数参数是一种<em>bad code smell</em>，这意味着该类可能有太多的责任，应该重构以更好地解决问题的分离问题。</p><p>Setter注入主要只应用于可选的依赖关系，这些依赖关系可以在类中分配合理的默认值。否则，必须在代码使用依赖关系的任何地方执行非空检查。setter注入的一个好处是setter方法使得该类的对象可以重新配置或稍后重新注入。</p></blockquote><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>最好避免字段注入。作为替代，您应该使用构造函数或setter方法来注入您的依赖关系。两者都有其优点和缺点，使用情况取决于具体情况。但是，由于这些方法可以混合使用，所以它不是一种二选一的选择，您可以在一个类中同时使用setter和构造函数注入。构造函数更适合于强制性的依赖关系以及旨在提供不变性的时候。Setter更适合可选的依赖项。</p><p>同时引入知乎<a href="https://www.zhihu.com/people/lqdxzhq" target="_blank" rel="noopener">赵翰青</a>的一段回答：</p><blockquote><p><strong>Field injection:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++ less code to write</span><br><span class="line">-- unsafe code</span><br><span class="line"> - more complicated to test</span><br></pre></td></tr></table></figure><p><strong>Constructor injection:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">++ safe code</span><br><span class="line"> - more code to write (see the hint to Lombok)</span><br><span class="line"> + easy to test</span><br></pre></td></tr></table></figure><p>虽然官方推荐Constructor injection，个人更喜欢Field injection。原因如下：</p><p>更少的代码</p><p>约定优于配置，都用Field injection也很安全</p><p>用spring做单元测试field injection并不复杂</p></blockquote><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.vojtechruzicka.com/field-dependency-injection-considered-harmful/" target="_blank" rel="noopener">https://www.vojtechruzicka.com/field-dependency-injection-considered-harmful/</a></p><p><a href="https://www.zhihu.com/question/52220502" target="_blank" rel="noopener">https://www.zhihu.com/question/52220502</a></p><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HikariCP与Druid的交锋</title>
      <link href="/2018/06/02/HikariCp%E4%B8%8EDruid%E7%9A%84%E4%BA%A4%E9%94%8B/"/>
      <url>/2018/06/02/HikariCp%E4%B8%8EDruid%E7%9A%84%E4%BA%A4%E9%94%8B/</url>
      
        <content type="html"><![CDATA[<p>看到GitHub上一个issue，关于HikariCP与Druid的性能，此间引出了两位大佬和众多网友的口水战。</p><p>余以为甚是有趣，特此翻译记录。</p><a id="more"></a><p><img src="https://i.loli.net/2018/06/02/5b1252d8e626a.jpg" alt="roit"></p><h1 id="先介绍下两位"><a href="#先介绍下两位" class="headerlink" title="先介绍下两位"></a>先介绍下两位</h1><h2 id="Druid"><a href="#Druid" class="headerlink" title="Druid"></a>Druid</h2><blockquote><p>Druid是Java语言中最好的数据库连接池。Druid能够提供强大的监控和扩展功能。</p></blockquote><h2 id="HikariCP"><a href="#HikariCP" class="headerlink" title="HikariCP"></a>HikariCP</h2><blockquote><p>Fast, simple, reliable. HikariCP is a “zero-overhead” production ready JDBC connection pool. At roughly 130Kb, the library is very light. </p></blockquote><p>极速、极简、可靠。HikariCP是一个“零开销”的数据库连接池。大约130kb，这个库非常轻量。</p><h1 id="一位印度小哥引起的口水战"><a href="#一位印度小哥引起的口水战" class="headerlink" title="一位印度小哥引起的口水战"></a>一位印度小哥引起的口水战</h1><p>PS：一下翻译几乎来自谷歌，我只是润色了下。。。之前翻译的全丢了，TMD :(</p><p>首先，一位印度小哥在HikariCP的issue上提了一个问题</p><blockquote><p>Hi, I find your analysis on Java DB pools very informative. I happen to come across this ‘druid’ pool from Alibaba: <a href="https://github.com/alibaba/druid/wiki/FAQ" target="_blank" rel="noopener">https://github.com/alibaba/druid/wiki/FAQ</a> (claims as the fastest DB pool in Java!).</p><p>From my very quick glance, seems it has some cool features. Any thoughts on this. Thanks.</p></blockquote><p>嗨，我发现你对Java DB池的分析非常丰富。 我碰巧发现了一个来自阿里巴巴的连接池Druid（声称是Java中速度最快的数据库池）。从我的快速浏览，似乎它有一些很酷的功能。 你对此有什么想法，请分享下，谢谢。</p><p>HikariCP作者<strong>brettwooldridge</strong>回答了这位印度小哥的问题</p><blockquote><p>A quick run of the benchmark on my desktop PC yielded the following:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Benchmark                                 (pool)   Mode  Samples       Score  Units</span><br><span class="line">c.z.h.b.ConnectionBench.cycleCnnection    hikari  thrpt       16   21206.330  ops/ms</span><br><span class="line">c.z.h.b.ConnectionBench.cycleCnnection    bone    thrpt       16   10389.139  ops/ms</span><br><span class="line">c.z.h.b.ConnectionBench.cycleCnnection    vibur   thrpt       16    6764.233  ops/ms</span><br><span class="line">c.z.h.b.ConnectionBench.cycleCnnection    tomcat  thrpt       16    2117.792  ops/ms</span><br><span class="line">c.z.h.b.ConnectionBench.cycleCnnection    c3p0    thrpt       16     128.447  ops/ms</span><br><span class="line">c.z.h.b.ConnectionBench.cycleCnnection    druid   thrpt       16     110.370  ops/ms</span><br><span class="line"></span><br><span class="line">c.z.h.b.StatementBench.cycleStatement     hikari  thrpt       16  130426.003  ops/ms</span><br><span class="line">c.z.h.b.StatementBench.cycleStatement     tomcat  thrpt       16   62071.180  ops/ms</span><br><span class="line">c.z.h.b.StatementBench.cycleStatement     druid   thrpt       16   54845.335  ops/ms</span><br><span class="line">c.z.h.b.StatementBench.cycleStatement     vibur   thrpt       16   33414.774  ops/ms</span><br><span class="line">c.z.h.b.StatementBench.cycleStatement     bone    thrpt       16   26551.919  ops/ms</span><br><span class="line">c.z.h.b.StatementBench.cycleStatement     c3p0    thrpt       16   15956.412  ops/ms</span><br></pre></td></tr></table></figure><p>So, at least in our benchmark, Druid was the <em>slowest</em> for obtaining and returning connections, and the third fastest for creating and closing statements.Druid was configured with similar settings to other pools in the benchmark:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">druid.setInitialSize(0);</span><br><span class="line">druid.setMinIdle(0);</span><br><span class="line">druid.setMaxActive(32);</span><br><span class="line">druid.setMaxWait(5000);</span><br><span class="line">druid.setValidationQuery(&quot;SELECT 1&quot;);</span><br><span class="line">druid.setTestOnBorrow(true);</span><br><span class="line">druid.setDefaultAutoCommit(false);</span><br><span class="line">druid.setDefaultTransactionIsolation(Connection.TRANSACTION_READ_COMMITTED);</span><br></pre></td></tr></table></figure><p>The benchmark page in their wiki does not show what settings they ran with, but I suspect that they disabled test-on-borrow. While I won’t say that is “cheating”, it is not how I would run a production pool. They also do not provide the source code to their test, as far as I can tell.</p></blockquote><p>作者给出了一个测试数据，说明了Druid在获得和归还连接上的速度最慢，创建和关闭statements的速度第三。同时还说，他们wiki中的页面没有显示他们运行的设置，但我怀疑他们禁用了借用测试。 虽然我不会说这是“作弊”，但我不会运行生产池。 据我所知，他们也没有提供源代码给他们的测试。</p><p><strong>bobwenx</strong>网友接着回复了</p><blockquote><p>druid was designed to focus on monitor and data access behavior enhance(like automatically database slice). it provides an SQL parser to analyze user’s SQL query and delegate most JDBC class to collect metrics. so if what you need is a JDBC monitor solution like newrelic, you may try Druid.</p></blockquote><p>Druid的目的是专注于监控和数据访问行为的增强（如自动数据库切片）。 它提供了一个SQL分析器来分析用户的SQL查询并委派大多数JDBC类来收集度量标准。<br>所以如果你需要的是像newrelic这样的JDBC监视器解决方案，你可以试试Druid。</p><p>作者<strong>brettwooldridge</strong>回复这位网友</p><blockquote><p><a href="https://github.com/bobwenx" target="_blank" rel="noopener">@bobwenx</a> It is a valid point. I will point out that New Relic is also supported by HikariCP through the <a href="https://github.com/brettwooldridge/HikariCP/wiki/Codahale-Metrics" target="_blank" rel="noopener">DropWizard Metrics integration</a>, but the metrics provided are “pool-level” metrics and not specific to query execution time, etc.</p></blockquote><p>这是一个有效的观点。 我会指出newrelic也受到HikariCP通过DropWizard指标集成的支持，但提供的度量标准是“池级”度量标准，并且不针对查询执行时间等。</p><p>此时天空一声巨响，Druid负责人温少出来找场子了</p><blockquote><p>If you configure maxWait property, druid pool use “fair mode ReentrantLock”, it’s bad performance.</p><p><a href="https://github.com/alibaba/druid/blob/master/src/main/java/com/alibaba/druid/pool/DruidAbstractDataSource.java" target="_blank" rel="noopener">https://github.com/alibaba/druid/blob/master/src/main/java/com/alibaba/druid/pool/DruidAbstractDataSource.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxWait</span><span class="params">(<span class="keyword">long</span> maxWaitMillis)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (maxWaitMillis == <span class="keyword">this</span>.maxWait) &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (maxWaitMillis &gt; <span class="number">0</span> &amp;&amp; useUnfairLock == <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.inited) &#123;</span><br><span class="line">           <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">           lock.lock();</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> ((!<span class="keyword">this</span>.inited) &amp;&amp; (!lock.isFair())) &#123;</span><br><span class="line">                   <span class="keyword">this</span>.lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">true</span>);</span><br><span class="line">                   <span class="keyword">this</span>.notEmpty = <span class="keyword">this</span>.lock.newCondition();</span><br><span class="line">                   <span class="keyword">this</span>.empty = <span class="keyword">this</span>.lock.newCondition();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (inited) &#123;</span><br><span class="line">           LOG.error(<span class="string">"maxWait changed : "</span> + <span class="keyword">this</span>.maxWait + <span class="string">" -&gt; "</span> + maxWaitMillis);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">this</span>.maxWait = maxWaitMillis;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>This is by design, because we had some problems in the production environment. Here are the relevant <a href="https://github.com/alibaba/druid/wiki/Druid%E9%94%81%E7%9A%84%E5%85%AC%E5%B9%B3%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">documents</a>, but I’m sorry, it is in Chinese.</p><p>Druid of PreparedStatementCache optimized, this is very important to enhance the mysql 5.5 &amp; oracle &amp; sqlserver &amp; db2 performance.</p><p>Druid has very stable ExceptionSorter, including Oracle / MySql / Alibaba Oceanbase etc.</p><p>In <a href="http://www.forbes.com/sites/jlim/2015/11/10/alibaba-group-sells-5bn-in-first-90-minutes-of-11-11-sale/#3de3850f1449" target="_blank" rel="noopener">Taobao large-scale high concurrency environment</a>, only two connection pools to work very well, <a href="https://github.com/alibaba/druid" target="_blank" rel="noopener">druid</a> and jboss connection pool.</p><p>Druid is not just a connection pool, he can do a very good extension, similar to Filter-Chain extension. Built-in Filter include <a href="https://github.com/alibaba/druid/wiki/%E7%AE%80%E4%BB%8B_WallFilter" target="_blank" rel="noopener">WallFilter</a>, <a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilter" target="_blank" rel="noopener">StatFilter</a>, <a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_LogFilter" target="_blank" rel="noopener">LogFilter</a>. Which can WallFilter defense SQL injection, StatFilter can do performance monitoring, LogFilter can output SQL logs.</p><p>Druid built very strong monitoring support.</p></blockquote><p>（你说都是自己人，回答的时候就中英双语并用呗。。。）</p><p>大意就是Druid启用了公平锁模式，这会降低性能。</p><p>至于为什么这么做，是因为他们为了解决一些生产上的问题，同时给了一个<a href="https://github.com/alibaba/druid/wiki/Druid%E9%94%81%E7%9A%84%E5%85%AC%E5%B9%B3%E6%A8%A1%E5%BC%8F%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">中文文档</a>。</p><p>Druid对PreparedStatementCache进行了优化，这对于增强mysql 5.5＆oracle＆sqlserver＆db2性能非常重要。</p><p>Druid拥有非常稳定的ExceptionSorter，包括Oracle / MySql /阿里巴巴Oceanbase等。</p><p>在淘宝大型高并发环境下，只有两个连接池工作得很好，druid和jboss连接池。</p><p>Druid不仅仅是一个连接池，他可以做一个很好的扩展，类似于Filter-Chain扩展。 内置过滤器包括WallFilter，StatFilter，LogFilter。 其中WallFilter可以防御SQL注入，StatFilter可以做性能监视，LogFilter可以输出SQL日志。</p><p>Druid建立了非常强大的监控支持。</p><p><strong>hrchu</strong>网友指出了提问者的一个小错误</p><blockquote><p>Hmmm I only see it claims as “the best” DB pool in Java, instead of the fast… 😕</p><p>Anyway I am glad to see more positive comparisons between HikariCP and Druid…</p></blockquote><p>提问者在修饰Druid上使用了“the fastest”，实际上Druid的wiki上用的是“the best”。同时这位网友很乐意看到大家对于两者之间更多积极的讨论</p><p>省略一些无意义的讨论…</p><p>一位中国网友说</p><blockquote><p>druid有阿里大数据量的验证，而HikariCP没有</p></blockquote><p>作者<strong>brettwooldridge</strong>回复中国网友</p><blockquote><p>HikariCP is one of the most widely used connection pools in the world, used by some of the largest companies, serving literally billions of users per day. Druid is rarely seen outside of China.</p></blockquote><p>HikariCP是世界上使用最广泛的连接池之一，由一些最大的公司使用，每天为数十亿用户提供服务。 Druid在中国以外很少见到。</p><p>紧接着这位中国网友对作者回复的“最大的公司”、“每天为数十亿用户服务”表示怀疑，希望作者能给出例子</p><p>作者<strong>brettwooldridge</strong>再次回复中国网友</p><blockquote><p>Wix.com by itself, for example hosts over 109 million websites and serves over 1 Billion requests per day. Atlassian has millions of customers for its products – no published numbers exists for daily usage.</p><p>HikariCP is the default pool for every application built with the Play framework, Slick, JOOS, and is now the default pool for Spring Boot.</p><p>HikariCP is resolved from the central maven repository over 300,000 times per month.</p><p><a href="https://github.com/brettwooldridge/HikariCP/blob/dev/documents/Wall-of-Fame.md" target="_blank" rel="noopener">Companies known to be using HikariCP</a>.</p></blockquote><p>意思就是我的东西就是这么牛13，你要的例子我都给你了</p><p>最后，另外一位中国网友做了如下中肯的评价</p><blockquote><p>我认为2个组件专注的方向不一样，各有特色和优点，不是组件如何，要看使用组件的人如何考虑，综合自己的需求选用，druid非常大一部分是为了监控和运维</p></blockquote><h1 id="综合网上的资料总结下"><a href="#综合网上的资料总结下" class="headerlink" title="综合网上的资料总结下"></a>综合网上的资料总结下</h1><h2 id="Druid偏大数据"><a href="#Druid偏大数据" class="headerlink" title="Druid偏大数据"></a>Druid偏大数据</h2><ul><li>需要交互式聚合和快速探究大量数据时；</li><li>需要实时查询分析时；</li><li>具有大量数据时，如每天数亿事件的新增、每天数10T数据的增加；</li><li>对数据尤其是大数据进行实时分析时；</li><li>需要一个高可用、高容错、高性能数据库时</li></ul><h2 id="HikariCP偏优化"><a href="#HikariCP偏优化" class="headerlink" title="HikariCP偏优化"></a>HikariCP偏优化</h2><ul><li><strong>字节码精简</strong> ：优化代码，直到编译后的字节码最少，这样，CPU缓存可以加载更多的程序代码；</li><li><strong>优化代理和拦截器</strong>：减少代码，例如HikariCP的Statement proxy只有100行代码，只有BoneCP的十分之一；</li><li><strong>自定义数组类型（FastStatementList）代替ArrayList</strong>：避免每次get()调用都要进行range check，避免调用remove()时的从头到尾的扫描；</li><li><strong>自定义集合类型（ConcurrentBag</strong>：提高并发读写的效率；</li><li><strong>其他针对BoneCP缺陷的优化</strong>，比如对于耗时超过一个CPU时间片的方法调用的研究（但没说具体怎么优化）。</li></ul><p>客官你怎么看。。。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://github.com/brettwooldridge/HikariCP/issues/232" target="_blank" rel="noopener">https://github.com/brettwooldridge/HikariCP/issues/232</a></p><p><a href="http://blog.didispace.com/Springboot-2-0-HikariCP-default-reason/" target="_blank" rel="noopener">http://blog.didispace.com/Springboot-2-0-HikariCP-default-reason/</a></p><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>转载：一句‘在吗’逼死人</title>
      <link href="/2018/06/02/%E8%BD%AC%E8%BD%BD%EF%BC%9A%E4%B8%80%E5%8F%A5%E2%80%98%E5%9C%A8%E5%90%97%E2%80%99%E9%80%BC%E6%AD%BB%E4%BA%BA/"/>
      <url>/2018/06/02/%E8%BD%AC%E8%BD%BD%EF%BC%9A%E4%B8%80%E5%8F%A5%E2%80%98%E5%9C%A8%E5%90%97%E2%80%99%E9%80%BC%E6%AD%BB%E4%BA%BA/</url>
      
        <content type="html"><![CDATA[<p>尼玛的，最近重新折腾了下hexo把之前几篇文章都给折腾没了，难受。。。这警示了我要定期备份something important，血的教训。</p><p>这是一篇关于挺有趣的文章，是一个知乎上的提问的回答。</p><p>特此记录~</p><a id="more"></a><h1 id="转载正文"><a href="#转载正文" class="headerlink" title="转载正文"></a>转载正文</h1><p>我相信大家肯定都遇到过以下两个场景？</p><p>场景一：</p><p>做为一个北上广深飘，在距你千里之外的家乡肯定有很多的同学和朋友，但是由于常年漂泊在外，基本上很少联系？突然有一天，几年都没有联系你的大学同学/同事，大晚上轻轻的问了一句：在吗？</p><p>你心中一惊，隐隐约约猜到这个“在吗”，后面有两个概率比较大的潜台词</p><p>1、亲，我xx月xx日在xx酒店结婚，可一定要来呀？</p><blockquote><p>来你妹，我们好像就见过一面留个电话而已，这是要广撒网呀</p></blockquote><p>2、哥们，我最近手头有点紧，周转不开，能不能先转手我xxx元，我下个月就还你。</p><blockquote><p>一个月后，你又失去了一个朋友…</p></blockquote><p><img src="https://pic1.zhimg.com/80/v2-5a37ecfb914ce6c29a2c9212f8fe395b_hd.jpg" alt="img"></p><p><img src="https://pic2.zhimg.com/80/v2-fa3ecdb4675755704b5cf634b32a45af_hd.jpg" alt="img"></p><p><img src="https://pic1.zhimg.com/80/v2-95ee7a5db4972f7e762fa2a452aae20b_hd.jpg" alt="img"></p><p>场景二：</p><p>在你的众多微信好友中，会经常有一类朋友在聊天之前问一句：在吗？</p><p>当你看到他的聊天记录的时候，回复个：在</p><p>当下次他在看到你给他回复这个“在”的时候，他好像已经忘了为什么问你：在吗？</p><p><img src="https://pic2.zhimg.com/80/v2-0870ab09ee97aaa242ad63826d8f66f9_hd.jpg" alt="img"></p><p>当然这个提问的对象很重要，如果是你熟知的家人朋友，那爱咋咋滴，随意问题.</p><p>如果问你”在吗”的这个人是你的前女/男朋友的时候？</p><blockquote><p>靠，怎么回事，难倒她想回心转意？<br>可是我已经有女朋友了？<br>万一她想和我复合怎么样？<br>我是冷漠的拒绝她<br>还是应该苦口婆心教育一下她。<br>万一她来xx（你工作的地方）了<br>我要不要见她？</p></blockquote><p>一晚未眠…</p><p>如果你的微信好友大于一千，你就会深深的感受到陌生人的一句：在吗？是多么的恐惧。</p><p>问：在吗？<br>回答：在<br>过了半天后<br>我可以请教你一个问题吗？<br>又过了半天<br>答：可以<br>….</p><p>当你被这种实在无聊又极为浪费时间的对话极度厌恶之后，慢慢的别人再次问你在吗的时候，你只能选择沉默。</p><blockquote><p>有人会认为你在假装高冷…<br>也许有人认为你在装B…<br>或许就是你不想叼他…<br>他想了很多，反正就是和他没有关系。</p></blockquote><p>当下次你问别人，“在吗”的时候，你只能沉默</p><p>当我以为只有我遇到这个情况的时候，我打开了知乎：</p><p><a href="https://www.zhihu.com/question/49356479/answer/389688859" target="_blank" rel="noopener">在微信上被问“在吗”，该如何回答？</a></p><p>以下三段摘录于知乎：</p><p><strong>Dr Husky</strong></p><p>有事直接说事，在吗多此一举。 否则对话会变成这样:</p><blockquote><p>A:“在吗”<br>半个小时后<br>B:“我在的，你在吗？”<br>半个小时后<br>A:“我在的，你在吗？”<br>………………<br>B:“我在的，你在吗？”<br>真实经历。<br>…………………………………………………………<br>其实A说完第二个我在的就应该建立连接了<br>啊三次握手协议啦</p></blockquote><p><strong>服装摆渡人</strong></p><p>在微信上接到两种消息是最想死的。</p><p>一种是语音，特别是谈工作时对方发过来一段又一段60s的语音，让人恨不能抓破手机屏幕；还有一种就是对方突然发来一句“在吗”，然后就没有下文了。</p><p>某匿名用户在知乎发帖说，她有一种“‘在吗’恐惧症”：</p><blockquote><p>有朋友周一问：“在吗？”<br>我周一晚上答：“在的，怎么啦？”<br>他周二早上说：“刚看到，现在在吗，问你个事情。”<br>我周二晚上答：“在的，你问吧。”<br>他周三下午说：“还在不？”<br>我周三晚上答：“在在，我一般晚上上QQ，你有事情时候我不在线，你就直接留言，我看到就回复。”<br>他周四上午说：“好吧，就是想问问，上次见你时候的口红是什么色号来着？”</p></blockquote><p>与这些打招呼只说“在吗”“在么”“在不在”的人交流，效率真是低得令人崩溃。</p><p><strong>橘落秋意浓</strong></p><blockquote><p>在微信上QQ上问”在吗”<br>我都能忍。<br>可是你们见过发短信问”在吗”的人吗？<br>简直没法忍。</p></blockquote><p>大家以为上面就是极品了吗？那是因为你没有看终极版</p><p><img src="https://pic3.zhimg.com/80/v2-73beaebf0ae6c7328b36d81c90dd5b73_hd.jpg" alt="img"></p><p>遇到这种情况，我们怎么回复？有模板：</p><p><strong>苏格拉小底裤</strong></p><p>你好，请你拿着你的手机打开语音朗读下面的文字对天起誓并发送给我：我找你聊天不是让你投票，注册、下载软件，也不是我要结婚了，更不是我有一个好的产品推荐给你，也不是问你借钱，更不是让你贷款，也不是给你分享鸡汤养生等一系列文章，只是单纯的想你了，想请你吃个饭联络一下感情。<br>————————语音结束分割线——————<br>我收到你的语音后会在三个工作日内给你答复。</p><p>轻飘飘版：</p><p><img src="https://pic4.zhimg.com/50/v2-201f17f593d8315aec34d61e64aeaa5b_hd.gif" alt="img"></p><p>直接版：</p><p><img src="https://pic3.zhimg.com/80/v2-405e4f22f76c79085472282b85c3a00c_hd.jpg" alt="img"></p><p>时光倒流版：</p><p><img src="https://pic4.zhimg.com/80/v2-7f1a747282f2a1cd316cf12574891cca_hd.jpg" alt="img"></p><p>在我的朋友圈一个朋友，已经被逼得昵称都改为：直接说事，在吗不回！</p><p><img src="https://pic2.zhimg.com/80/v2-35fa01625eacb14bc55d00dacc25f683_hd.jpg" alt="img"></p><p>其实当你问我”在吗？”的时候我一直在考虑我要不要在！因此当你有什么想要问我的时候，想尽量一口气说完你的问题。如果这个问题在我能够回答或者解决的情况下，我会尽量回答：在!</p><h1 id="出处"><a href="#出处" class="headerlink" title="出处"></a>出处</h1><p> <a href="http://www.mooooc.com/" target="_blank" rel="noopener"><strong>纯洁的微笑-ityouknow</strong></a></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.mooooc.com/life/2018/05/12/zai-ma.html" target="_blank" rel="noopener">http://www.mooooc.com/life/2018/05/12/zai-ma.html</a></p><p><a href="https://www.zhihu.com/question/49356479/answer/389688859" target="_blank" rel="noopener">https://www.zhihu.com/question/49356479/answer/389688859</a></p><blockquote><p><em>大部分正义感都是虚伪的 聊胜于无   —————————————沃德彭尤·胡某</em></p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 闲谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Quartz实现持久化</title>
      <link href="/2018/05/29/Quartz%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2018/05/29/Quartz%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>最近项目中出现需求为：给定参数和时间，定时发送短信。同时希望如果服务器挂了能够重新运行这个定时任务。</p><p>准备使用quartz做。</p><p>所有代码在<a href="https://github.com/qianhangkang/justdoit/tree/master/quartz" target="_blank" rel="noopener">GitHub</a>上，帮助到你就点个赞呗~</p><p>quartz的任务存储（Job Stores）模式有三种：RAMJobStore、JDBCJobStore、TerracottaJobStore</p><a id="more"></a><h1 id="三种任务存储模式"><a href="#三种任务存储模式" class="headerlink" title="三种任务存储模式"></a>三种任务存储模式</h1><h2 id="RAMJobStore"><a href="#RAMJobStore" class="headerlink" title="RAMJobStore"></a>RAMJobStore</h2><p>最简单的、性能最高的、也是<strong>默认</strong>的一种jobstore，所有数据存放在内存中，如果程序重启或关闭，所有的job都会丢失。</p><h2 id="JDBCJobStore"><a href="#JDBCJobStore" class="headerlink" title="JDBCJobStore"></a>JDBCJobStore</h2><p>性能比RAMJobStore差，所有数据存放在数据库中， JDBCJobStore几乎适用于任何数据库。要使用JDBCJobStore，您必须首先为Quartz创建一组数据库表以供使用。当然，你<strong>不需要</strong>实现任何一条SQL语句。</p><p>在配置和启动JDBCJobStore之前，您需要确定应用程序需要什么类型的事务。</p><ul><li>如果您不需要将调度命令（例如添加和删除触发器）与其他事务绑定在一起，那么您可以让Quartz使用<strong>JobStoreTX</strong>作为JobStore（这是最常见的选择）来管理事务。</li><li>如果您需要Quartz与其他事务一起工作（即在J2EE应用程序服务器中），那么您应该使用<strong>JobStoreCMT–</strong>在这种情况下，Quartz将让应用程序服务器容器管理事务。</li></ul><h2 id="TerracottaJobStore"><a href="#TerracottaJobStore" class="headerlink" title="TerracottaJobStore"></a>TerracottaJobStore</h2><p>TerracottaJobStore是Quartz 1.7的新成员。它提供了一种扩展和健壮性的方法，而不需要使用数据库。这意味着您的数据库可以从Quartz中免费加载，并且可以将其所有资源保存到其他应用程序中。</p><h1 id="原生持久化解决方案"><a href="#原生持久化解决方案" class="headerlink" title="原生持久化解决方案"></a>原生持久化解决方案</h1><blockquote><p>IDE：idea</p><p>jdk：1.8</p><p>框架：springboot (v2.0.2.RELEASE)、quartz(v2.3.0)、lombok</p></blockquote><h2 id="quartz持久化需要的表SQL"><a href="#quartz持久化需要的表SQL" class="headerlink" title="quartz持久化需要的表SQL"></a>quartz持久化需要的表SQL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># In your Quartz properties file, you will need to set   </span></span><br><span class="line"><span class="comment"># org.quartz.jobStore.driverDelegateClass = org.quartz.impl.jdbcjobstore.StdJDBCDelegate </span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment"># By: Ron Cordell - roncordell</span></span><br><span class="line"><span class="comment"># I didn't see this anywhere, so I thought I'd post it here. </span></span><br><span class="line"><span class="comment"># This is the script from Quartz to create the tables in a MySQL database,</span></span><br><span class="line"><span class="comment"># modified to use INNODB instead of MYISAM. </span></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_FIRED_TRIGGERS;  </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_PAUSED_TRIGGER_GRPS;  </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_SCHEDULER_STATE;  </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_LOCKS;  </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_SIMPLE_TRIGGERS;  </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_SIMPROP_TRIGGERS;  </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_CRON_TRIGGERS;  </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_BLOB_TRIGGERS;  </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_TRIGGERS;  </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_JOB_DETAILS;  </span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> QRTZ_CALENDARS;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_JOB_DETAILS(  </span><br><span class="line">SCHED_NAME <span class="built_in">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">JOB_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">JOB_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">DESCRIPTION <span class="built_in">VARCHAR</span>(<span class="number">250</span>) <span class="literal">NULL</span>,  </span><br><span class="line">JOB_CLASS_NAME <span class="built_in">VARCHAR</span>(<span class="number">250</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">IS_DURABLE <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">IS_NONCONCURRENT <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">IS_UPDATE_DATA <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">REQUESTS_RECOVERY <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">JOB_DATA <span class="built_in">BLOB</span> <span class="literal">NULL</span>,  </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (SCHED_NAME,JOB_NAME,JOB_GROUP))  </span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_TRIGGERS (  </span><br><span class="line">SCHED_NAME <span class="built_in">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">TRIGGER_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">TRIGGER_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">JOB_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">JOB_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">DESCRIPTION <span class="built_in">VARCHAR</span>(<span class="number">250</span>) <span class="literal">NULL</span>,  </span><br><span class="line">NEXT_FIRE_TIME <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="literal">NULL</span>,  </span><br><span class="line">PREV_FIRE_TIME <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="literal">NULL</span>,  </span><br><span class="line"><span class="keyword">PRIORITY</span> <span class="built_in">INTEGER</span> <span class="literal">NULL</span>,  </span><br><span class="line">TRIGGER_STATE <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">TRIGGER_TYPE <span class="built_in">VARCHAR</span>(<span class="number">8</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">START_TIME <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">END_TIME <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="literal">NULL</span>,  </span><br><span class="line">CALENDAR_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="literal">NULL</span>,  </span><br><span class="line">MISFIRE_INSTR <span class="built_in">SMALLINT</span>(<span class="number">2</span>) <span class="literal">NULL</span>,  </span><br><span class="line">JOB_DATA <span class="built_in">BLOB</span> <span class="literal">NULL</span>,  </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),  </span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (SCHED_NAME,JOB_NAME,JOB_GROUP)  </span><br><span class="line"><span class="keyword">REFERENCES</span> QRTZ_JOB_DETAILS(SCHED_NAME,JOB_NAME,JOB_GROUP))  </span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_SIMPLE_TRIGGERS (  </span><br><span class="line">SCHED_NAME <span class="built_in">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">TRIGGER_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">TRIGGER_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">REPEAT_COUNT <span class="built_in">BIGINT</span>(<span class="number">7</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">REPEAT_INTERVAL <span class="built_in">BIGINT</span>(<span class="number">12</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">TIMES_TRIGGERED <span class="built_in">BIGINT</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),  </span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)  </span><br><span class="line"><span class="keyword">REFERENCES</span> QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))  </span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_CRON_TRIGGERS (  </span><br><span class="line">SCHED_NAME <span class="built_in">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">TRIGGER_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">TRIGGER_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">CRON_EXPRESSION <span class="built_in">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">TIME_ZONE_ID <span class="built_in">VARCHAR</span>(<span class="number">80</span>),  </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),  </span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)  </span><br><span class="line"><span class="keyword">REFERENCES</span> QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))  </span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_SIMPROP_TRIGGERS  </span><br><span class="line">  (            </span><br><span class="line">    SCHED_NAME <span class="built_in">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    TRIGGER_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    TRIGGER_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    STR_PROP_1 <span class="built_in">VARCHAR</span>(<span class="number">512</span>) <span class="literal">NULL</span>,  </span><br><span class="line">    STR_PROP_2 <span class="built_in">VARCHAR</span>(<span class="number">512</span>) <span class="literal">NULL</span>,  </span><br><span class="line">    STR_PROP_3 <span class="built_in">VARCHAR</span>(<span class="number">512</span>) <span class="literal">NULL</span>,  </span><br><span class="line">    INT_PROP_1 <span class="built_in">INT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    INT_PROP_2 <span class="built_in">INT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    LONG_PROP_1 <span class="built_in">BIGINT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    LONG_PROP_2 <span class="built_in">BIGINT</span> <span class="literal">NULL</span>,  </span><br><span class="line">    DEC_PROP_1 <span class="built_in">NUMERIC</span>(<span class="number">13</span>,<span class="number">4</span>) <span class="literal">NULL</span>,  </span><br><span class="line">    DEC_PROP_2 <span class="built_in">NUMERIC</span>(<span class="number">13</span>,<span class="number">4</span>) <span class="literal">NULL</span>,  </span><br><span class="line">    BOOL_PROP_1 <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="literal">NULL</span>,  </span><br><span class="line">    BOOL_PROP_2 <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="literal">NULL</span>,  </span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),  </span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)   </span><br><span class="line">    <span class="keyword">REFERENCES</span> QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))  </span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_BLOB_TRIGGERS (  </span><br><span class="line">SCHED_NAME <span class="built_in">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">TRIGGER_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">TRIGGER_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">BLOB_DATA <span class="built_in">BLOB</span> <span class="literal">NULL</span>,  </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP),  </span><br><span class="line"><span class="keyword">INDEX</span> (SCHED_NAME,TRIGGER_NAME, TRIGGER_GROUP),  </span><br><span class="line"><span class="keyword">FOREIGN</span> <span class="keyword">KEY</span> (SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP)  </span><br><span class="line"><span class="keyword">REFERENCES</span> QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP))  </span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_CALENDARS (  </span><br><span class="line">SCHED_NAME <span class="built_in">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">CALENDAR_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">CALENDAR <span class="built_in">BLOB</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (SCHED_NAME,CALENDAR_NAME))  </span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_PAUSED_TRIGGER_GRPS (  </span><br><span class="line">SCHED_NAME <span class="built_in">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">TRIGGER_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (SCHED_NAME,TRIGGER_GROUP))  </span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_FIRED_TRIGGERS (  </span><br><span class="line">SCHED_NAME <span class="built_in">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">ENTRY_ID <span class="built_in">VARCHAR</span>(<span class="number">95</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">TRIGGER_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">TRIGGER_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">INSTANCE_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">FIRED_TIME <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">SCHED_TIME <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line"><span class="keyword">PRIORITY</span> <span class="built_in">INTEGER</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">STATE <span class="built_in">VARCHAR</span>(<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">JOB_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="literal">NULL</span>,  </span><br><span class="line">JOB_GROUP <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="literal">NULL</span>,  </span><br><span class="line">IS_NONCONCURRENT <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="literal">NULL</span>,  </span><br><span class="line">REQUESTS_RECOVERY <span class="built_in">VARCHAR</span>(<span class="number">1</span>) <span class="literal">NULL</span>,  </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (SCHED_NAME,ENTRY_ID))  </span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_SCHEDULER_STATE (  </span><br><span class="line">SCHED_NAME <span class="built_in">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">INSTANCE_NAME <span class="built_in">VARCHAR</span>(<span class="number">200</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">LAST_CHECKIN_TIME <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">CHECKIN_INTERVAL <span class="built_in">BIGINT</span>(<span class="number">13</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (SCHED_NAME,INSTANCE_NAME))  </span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> QRTZ_LOCKS (  </span><br><span class="line">SCHED_NAME <span class="built_in">VARCHAR</span>(<span class="number">120</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">LOCK_NAME <span class="built_in">VARCHAR</span>(<span class="number">40</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,  </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (SCHED_NAME,LOCK_NAME))  </span><br><span class="line"><span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_J_REQ_RECOVERY <span class="keyword">ON</span> QRTZ_JOB_DETAILS(SCHED_NAME,REQUESTS_RECOVERY);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_J_GRP <span class="keyword">ON</span> QRTZ_JOB_DETAILS(SCHED_NAME,JOB_GROUP);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_T_J <span class="keyword">ON</span> QRTZ_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_T_JG <span class="keyword">ON</span> QRTZ_TRIGGERS(SCHED_NAME,JOB_GROUP);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_T_C <span class="keyword">ON</span> QRTZ_TRIGGERS(SCHED_NAME,CALENDAR_NAME);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_T_G <span class="keyword">ON</span> QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_T_STATE <span class="keyword">ON</span> QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_T_N_STATE <span class="keyword">ON</span> QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP,TRIGGER_STATE);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_T_N_G_STATE <span class="keyword">ON</span> QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_GROUP,TRIGGER_STATE);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_T_NEXT_FIRE_TIME <span class="keyword">ON</span> QRTZ_TRIGGERS(SCHED_NAME,NEXT_FIRE_TIME);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_T_NFT_ST <span class="keyword">ON</span> QRTZ_TRIGGERS(SCHED_NAME,TRIGGER_STATE,NEXT_FIRE_TIME);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_T_NFT_MISFIRE <span class="keyword">ON</span> QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_T_NFT_ST_MISFIRE <span class="keyword">ON</span> QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_STATE);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_T_NFT_ST_MISFIRE_GRP <span class="keyword">ON</span> QRTZ_TRIGGERS(SCHED_NAME,MISFIRE_INSTR,NEXT_FIRE_TIME,TRIGGER_GROUP,TRIGGER_STATE);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_FT_TRIG_INST_NAME <span class="keyword">ON</span> QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_FT_INST_JOB_REQ_RCVRY <span class="keyword">ON</span> QRTZ_FIRED_TRIGGERS(SCHED_NAME,INSTANCE_NAME,REQUESTS_RECOVERY);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_FT_J_G <span class="keyword">ON</span> QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_NAME,JOB_GROUP);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_FT_JG <span class="keyword">ON</span> QRTZ_FIRED_TRIGGERS(SCHED_NAME,JOB_GROUP);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_FT_T_G <span class="keyword">ON</span> QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_NAME,TRIGGER_GROUP);  </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">INDEX</span> IDX_QRTZ_FT_TG <span class="keyword">ON</span> QRTZ_FIRED_TRIGGERS(SCHED_NAME,TRIGGER_GROUP);  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure><h2 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.hongkong&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;demo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;demo&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--quartz--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--mysql--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--lombok--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--mybatis，提供DataSource，也可以使用springboot的jdbc，如下--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--&amp;lt;!&amp;ndash;springboot的jdbc&amp;ndash;&amp;gt;--&gt;</span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;/dependency&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;groupId&gt;com.h2database&lt;/groupId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;artifactId&gt;h2&lt;/artifactId&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;/dependency&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h2 id="Java代码设置quartz配置"><a href="#Java代码设置quartz配置" class="headerlink" title="Java代码设置quartz配置"></a>Java代码设置quartz配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * quartz的Java配置文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QuartzListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SchedulerFactoryBean <span class="title">schedulerFactoryBean</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        SchedulerFactoryBean schedulerFactoryBean = <span class="keyword">new</span> SchedulerFactoryBean();</span><br><span class="line">        schedulerFactoryBean.setSchedulerName(<span class="string">"MsmJobSchedule"</span>);</span><br><span class="line">        <span class="comment">//设置数据库数据源</span></span><br><span class="line">        schedulerFactoryBean.setDataSource(dataSource);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//quartz参数</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.put(<span class="string">"org.quartz.scheduler.instanceName"</span>, <span class="string">"MsmJobSchedule"</span>);</span><br><span class="line">        prop.put(<span class="string">"org.quartz.scheduler.instanceId"</span>, <span class="string">"AUTO"</span>);</span><br><span class="line">        <span class="comment">//线程池配置</span></span><br><span class="line">        prop.put(<span class="string">"org.quartz.threadPool.class"</span>, <span class="string">"org.quartz.simpl.SimpleThreadPool"</span>);</span><br><span class="line">        <span class="comment">//并行的线程数，默认为10</span></span><br><span class="line">        prop.put(<span class="string">"org.quartz.threadPool.threadCount"</span>, <span class="string">"10"</span>);</span><br><span class="line">        <span class="comment">//线程优先级，默认为5</span></span><br><span class="line">        prop.put(<span class="string">"org.quartz.threadPool.threadPriority"</span>, <span class="string">"5"</span>);</span><br><span class="line">        <span class="comment">//JobStore配置</span></span><br><span class="line">        prop.put(<span class="string">"org.quartz.jobStore.class"</span>, <span class="string">"org.quartz.impl.jdbcjobstore.JobStoreTX"</span>);</span><br><span class="line">        <span class="comment">//配置是否启动自动加载数据库内的定时任务，默认true</span></span><br><span class="line">        prop.put(<span class="string">"org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread"</span>,<span class="string">"true"</span>);</span><br><span class="line">        <span class="comment">//持久化方式配置数据驱动，MySQL数据库</span></span><br><span class="line">        prop.put(<span class="string">"org.quartz.jobStore.driverDelegateClass"</span>,<span class="string">"org.quartz.impl.jdbcjobstore.StdJDBCDelegate"</span>);</span><br><span class="line">        <span class="comment">//设置property</span></span><br><span class="line">        schedulerFactoryBean.setQuartzProperties(prop);</span><br><span class="line">        <span class="comment">//延时启动10s</span></span><br><span class="line">        schedulerFactoryBean.setStartupDelay(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> schedulerFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scheduler <span class="title">scheduler</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        Scheduler scheduler = schedulerFactoryBean(dataSource).getScheduler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//每次schedule初始化时添加监听器，否则程序重启后之前的任务无法被监听</span></span><br><span class="line">            log.info(<span class="string">"添加监听器至schedule"</span>);</span><br><span class="line">            scheduler.getListenerManager().addJobListener(listener);<span class="comment">//listener自动注入</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            log.debug(<span class="string">"监听器添加至schedule失败"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> scheduler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现Job接口"><a href="#实现Job接口" class="headerlink" title="实现Job接口"></a>实现Job接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Job执行的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> context job上下文</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> JobExecutionException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        log.info(<span class="string">"任务&#123;&#125;开始执行任务"</span>,context.getFireInstanceId());</span><br><span class="line">        <span class="comment">//得到传入job的参数</span></span><br><span class="line">        JobDataMap dataMap = context.getJobDetail().getJobDataMap();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"任务&#123;&#125;执行结束"</span>,context.getFireInstanceId());</span><br><span class="line">        context.setResult(String.format(<span class="string">"%s say 'hello' to listener"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现JobListener接口"><a href="#实现JobListener接口" class="headerlink" title="实现JobListener接口"></a>实现JobListener接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzListener</span> <span class="keyword">implements</span> <span class="title">JobListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"QuartzListener"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jobToBeExecuted</span><span class="params">(JobExecutionContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//监听job执行之前</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jobExecutionVetoed</span><span class="params">(JobExecutionContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//监听job的trigger被触发，但是job被JobListener禁止执行事件</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jobWasExecuted</span><span class="params">(JobExecutionContext context, JobExecutionException jobException)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//监听job执行完成后</span></span><br><span class="line">        log.info(<span class="string">"监听器收到job执行结果:&#123;&#125;"</span>, context.getResult());<span class="comment">//打印job执行结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="向schedule添加自定义MyJob"><a href="#向schedule添加自定义MyJob" class="headerlink" title="向schedule添加自定义MyJob"></a>向schedule添加自定义MyJob</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QuartzListener listener;<span class="comment">//监听器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个定时任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter 传入任务的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startDate 执行的时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addJob</span><span class="params">(String parameter,Date startDate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置一个标识符</span></span><br><span class="line">        String id = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">//设置传入job的参数</span></span><br><span class="line">        JobDataMap dataMap = <span class="keyword">new</span> JobDataMap();</span><br><span class="line">        dataMap.put(<span class="string">"parameter"</span>, parameter);</span><br><span class="line">        <span class="comment">//jobDetail</span></span><br><span class="line">        JobDetail jobDetail = JobBuilder.newJob(MyJob.class).withIdentity("job---"+id,id).setJobData(dataMap).build();</span><br><span class="line">        <span class="comment">//trigger</span></span><br><span class="line">        Trigger trigger = TriggerBuilder.newTrigger().withIdentity(<span class="string">"trigger---"</span>+id,id).startAt(startDate).build();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            scheduler.scheduleJob(jobDetail,trigger);</span><br><span class="line">            log.info(<span class="string">"job---&#123;&#125;加入任务"</span>,id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="controller层"><a href="#controller层" class="headerlink" title="controller层"></a>controller层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QuartzService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个任务，30s后执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter 传入的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/add/&#123;parameter&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(@PathVariable(value = <span class="string">"parameter"</span>)</span> String parameter) </span>&#123;</span><br><span class="line">        <span class="comment">//设置30s后执行</span></span><br><span class="line">        Date now = <span class="keyword">new</span> Date();</span><br><span class="line">        log.info(<span class="string">"现在时间为&#123;&#125;"</span>,now);</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.setTime(now);</span><br><span class="line">        calendar.add(Calendar.SECOND, <span class="number">30</span>);</span><br><span class="line">        <span class="comment">//执行时间</span></span><br><span class="line">        Date startDate = calendar.getTime();</span><br><span class="line">        log.info(<span class="string">"任务执行的时间为&#123;&#125;"</span>, startDate);</span><br><span class="line">        service.addJob(parameter, startDate);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"add successfully"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到当前任务执行的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/job"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">job</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;Trigger&gt; triggers = <span class="keyword">null</span>;</span><br><span class="line">        String jobName = <span class="keyword">null</span>;</span><br><span class="line">        String jobGroup = <span class="keyword">null</span>;</span><br><span class="line">        Date nextFireTime = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String groupName : scheduler.getJobGroupNames()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (JobKey jobKey : scheduler.getJobKeys(GroupMatcher.jobGroupEquals(groupName))) &#123;</span><br><span class="line">                    jobName = jobKey.getName();</span><br><span class="line">                    jobGroup = jobKey.getGroup();</span><br><span class="line">                    <span class="comment">//get trigger</span></span><br><span class="line">                    triggers = (List&lt;Trigger&gt;) scheduler.getTriggersOfJob(jobKey);</span><br><span class="line">                    nextFireTime = triggers.get(<span class="number">0</span>).getNextFireTime();</span><br><span class="line">                    res.add(<span class="string">"[jobName] : "</span> + jobName + <span class="string">" [groupName] : "</span></span><br><span class="line">                            + jobGroup + <span class="string">" - "</span> + nextFireTime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果演示"><a href="#结果演示" class="headerlink" title="结果演示"></a>结果演示</h2><h3 id="通过接口添加一个job"><a href="#通过接口添加一个job" class="headerlink" title="通过接口添加一个job"></a>通过接口添加一个job</h3><p>参数：helloworld~~ </p><p><img src="https://i.loli.net/2018/05/30/5b0e0f8db01b3.png" alt=""> </p><p><img src="https://i.loli.net/2018/05/30/5b0e0f8dbff34.png" alt=""></p><h3 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h3><p>QRTZ_JOB_DETAILS表</p><p><img src="https://i.loli.net/2018/05/30/5b0e0f8db9358.png" alt=""></p><p>QRTZ_SIMPLE_TRIGGERS表</p><p><img src="https://i.loli.net/2018/05/30/5b0e0f8dba9c3.png" alt=""></p><h3 id="通过接口查看待执行的任务"><a href="#通过接口查看待执行的任务" class="headerlink" title="通过接口查看待执行的任务"></a>通过接口查看待执行的任务</h3><p><img src="https://i.loli.net/2018/05/30/5b0e0f8dc1956.png" alt=""></p><h3 id="一分钟后任务执行"><a href="#一分钟后任务执行" class="headerlink" title="一分钟后任务执行"></a>一分钟后任务执行</h3><p><img src="https://i.loli.net/2018/05/30/5b0e0f8dc2fff.png" alt=""></p><h2 id="监听器存在的一个问题"><a href="#监听器存在的一个问题" class="headerlink" title="监听器存在的一个问题"></a>监听器存在的一个问题</h2><p>如果不在schedule初始化时将监听器添加进去，那么会出现应用程序重启后会无法监听之前job的情况。</p><h1 id="自定义解决方案"><a href="#自定义解决方案" class="headerlink" title="自定义解决方案"></a>自定义解决方案</h1><p>上流程图</p><p><img src="https://i.loli.net/2018/05/31/5b0fb1ca774b7.png" alt=""></p><h2 id="我的自定义的quartz持久化表"><a href="#我的自定义的quartz持久化表" class="headerlink" title="我的自定义的quartz持久化表"></a>我的自定义的quartz持久化表</h2><p>仅供参考，请自行修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># author:hongkong</span><br><span class="line"># date:2018年05月31日15:57:51</span><br><span class="line"></span><br><span class="line">CREATE TABLE `PTP_MSM_TASK` (</span><br><span class="line">  `ID` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;任务id&apos;,</span><br><span class="line">  `JOB_NAME` varchar(40) DEFAULT NULL COMMENT &apos;任务名&apos;,</span><br><span class="line">  `PARAMETER` varchar(2000) DEFAULT NULL COMMENT &apos;短信参数&apos;,</span><br><span class="line">  `EXECUTE_DATE` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;执行日期&apos;,</span><br><span class="line">  `STATUS` int(11) NOT NULL COMMENT &apos;执行状态，0--未执行，1--执行成功，2--执行失败&apos;,</span><br><span class="line">  `CRON` varchar(40) DEFAULT NULL COMMENT &apos;cron表达式&apos;,</span><br><span class="line">  `TYPE` INT DEFAULT 0 NOT NULL COMMENT &apos;任务执行类型，0--立即执行，1--延时执行一次，2--利用cron表达式执行&apos;</span><br><span class="line">  PRIMARY KEY (`ID`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;任务表&apos;;</span><br></pre></td></tr></table></figure><h2 id="pom文件-1"><a href="#pom文件-1" class="headerlink" title="pom文件"></a>pom文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.hongkong&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;demo&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;packaging&gt;jar&lt;/packaging&gt;</span><br><span class="line"></span><br><span class="line">    &lt;name&gt;demo&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.0.2.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;</span><br><span class="line">        &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.3.2&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">            &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><h2 id="Java代码设置quartz配置-1"><a href="#Java代码设置quartz配置-1" class="headerlink" title="Java代码设置quartz配置"></a>Java代码设置quartz配置</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * quartz的Java配置文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QuartzListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SchedulerFactoryBean <span class="title">schedulerFactoryBean</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        SchedulerFactoryBean schedulerFactoryBean = <span class="keyword">new</span> SchedulerFactoryBean();</span><br><span class="line">        schedulerFactoryBean.setSchedulerName(<span class="string">"MsmJobSchedule"</span>);</span><br><span class="line">        <span class="comment">//quartz参数</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.put(<span class="string">"org.quartz.scheduler.instanceName"</span>, <span class="string">"MsmJobSchedule"</span>);</span><br><span class="line">        prop.put(<span class="string">"org.quartz.scheduler.instanceId"</span>, <span class="string">"AUTO"</span>);</span><br><span class="line">        <span class="comment">//设置property</span></span><br><span class="line">        schedulerFactoryBean.setQuartzProperties(prop);</span><br><span class="line">        <span class="comment">//延时启动10s</span></span><br><span class="line">        schedulerFactoryBean.setStartupDelay(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> schedulerFactoryBean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Scheduler <span class="title">scheduler</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        Scheduler scheduler = schedulerFactoryBean(dataSource).getScheduler();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//每次schedule初始化时添加监听器，否则程序重启后之前的任务无法被监听</span></span><br><span class="line">            log.info(<span class="string">"添加监听器至schedule"</span>);</span><br><span class="line">            scheduler.getListenerManager().addJobListener(listener);<span class="comment">//listener自动注入</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            log.debug(<span class="string">"监听器添加至schedule失败"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> scheduler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现job接口"><a href="#实现job接口" class="headerlink" title="实现job接口"></a>实现job接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Job执行的方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context job上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//得到传入job的参数</span></span><br><span class="line">    JobDataMap dataMap = context.getJobDetail().getJobDataMap();</span><br><span class="line">    String parameter = dataMap.getString(<span class="string">"parameter"</span>);</span><br><span class="line">    <span class="comment">//quartz自动生成的唯一id</span></span><br><span class="line">    String instanceId = context.getFireInstanceId();</span><br><span class="line">    log.info(<span class="string">"任务&#123;&#125;，参数为&#123;&#125;开始执行任务"</span>, instanceId, parameter);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> time = random.nextInt(<span class="number">5000</span>) + <span class="number">1000</span>;</span><br><span class="line">        Thread.sleep(time);</span><br><span class="line">        log.info(<span class="string">"任务&#123;&#125;，参数为&#123;&#125;，时间为&#123;&#125;执行结束"</span>, instanceId, parameter, time);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现JobListener接口-1"><a href="#实现JobListener接口-1" class="headerlink" title="实现JobListener接口"></a>实现JobListener接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzListener</span> <span class="keyword">implements</span> <span class="title">JobListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PtpMsmTaskRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"QuartzListener"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jobToBeExecuted</span><span class="params">(JobExecutionContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//监听job执行之前</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jobExecutionVetoed</span><span class="params">(JobExecutionContext context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//监听job的trigger被触发，但是job被JobListener禁止执行事件</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">jobWasExecuted</span><span class="params">(JobExecutionContext context, JobExecutionException jobException)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 得到任务的name</span></span><br><span class="line"><span class="comment">         * 根据name查找数据库</span></span><br><span class="line"><span class="comment">         * 若不存在记录，记录异常</span></span><br><span class="line"><span class="comment">         * 否则，判断传入的异常是否为空，更新对应的任务状态</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        String name = context.getJobDetail().getKey().getName();</span><br><span class="line">        PtpMsmTask job = repository.findOneByName(name);</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(job)) &#123;</span><br><span class="line">            log.debug(<span class="string">"数据库中无法查询到name为&#123;&#125;的任务"</span>,name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//存在记录，判断是否执行时抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(jobException)) &#123;</span><br><span class="line">            <span class="comment">//执行成功，没有异常</span></span><br><span class="line">            job.setStatus(TaskStatusEnum.SUCCESS.getType());</span><br><span class="line">            <span class="keyword">int</span> count = repository.updateByName(job,name);</span><br><span class="line">            <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                log.debug(<span class="string">"更新job&#123;&#125;失败"</span>, job);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            log.info(<span class="string">"任务为&#123;&#125;，描述为&#123;&#125;的任务执行完成"</span>,name, context.getJobDetail().getDescription());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//执行时发生异常</span></span><br><span class="line">        job.setStatus(TaskStatusEnum.FAIL.getType());</span><br><span class="line">        <span class="keyword">int</span> count = repository.updateByName(job,name);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">"更新job&#123;&#125;失败"</span>, job);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(<span class="string">"任务为&#123;&#125;，描述为&#123;&#125;的任务执行发生异常&#123;&#125;"</span>,name, context.getJobDetail().getDescription(),jobException.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="添加job"><a href="#添加job" class="headerlink" title="添加job"></a>添加job</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PtpMsmTaskRepository repository;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * schedule被注入后执行的初始化函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;PtpMsmTask&gt; list = repository.findListByStatus(TaskStatusEnum.NOT_PERFORME.getType());</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(list) || list.isEmpty()) &#123;</span><br><span class="line">            log.info(<span class="string">"&#123;&#125;时间点之前不存在未执行的任务"</span>,<span class="keyword">new</span> Date());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将数据库中未执行的任务重新加入至schedule中</span></span><br><span class="line">        String name = <span class="keyword">null</span>;</span><br><span class="line">        Date startDate = <span class="keyword">null</span>;</span><br><span class="line">        JobDetail jobDetail = <span class="keyword">null</span>;</span><br><span class="line">        Trigger trigger = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (PtpMsmTask job : list) &#123;</span><br><span class="line">            JobDataMap dataMap = <span class="keyword">new</span> JobDataMap();</span><br><span class="line">            dataMap.put(<span class="string">"parameter"</span>, job.getParameter());</span><br><span class="line">            name = job.getJobName();</span><br><span class="line">            startDate = job.getExecuteDate();</span><br><span class="line">            jobDetail = JobBuilder.newJob(MyJob<span class="class">.<span class="keyword">class</span>).<span class="title">withIdentity</span>(<span class="title">name</span>,<span class="title">name</span>).<span class="title">setJobData</span>(<span class="title">dataMap</span>).<span class="title">build</span>()</span>;</span><br><span class="line">            trigger = TriggerBuilder.newTrigger().withIdentity(name,name).startAt(startDate).build();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                scheduler.scheduleJob(jobDetail,trigger);</span><br><span class="line">                log.info(<span class="string">"job---&#123;&#125;加入至schedule"</span>,name);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个定时任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter 传入任务的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> startDate 执行的时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addJob</span><span class="params">(String parameter,Date startDate)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置一个标识符</span></span><br><span class="line">        String id = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">//设置传入job的参数</span></span><br><span class="line">        JobDataMap dataMap = <span class="keyword">new</span> JobDataMap();</span><br><span class="line">        dataMap.put(<span class="string">"parameter"</span>, parameter);</span><br><span class="line">        <span class="comment">//jobDetail</span></span><br><span class="line">        JobDetail jobDetail = JobBuilder.newJob(MyJob<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">withIdentity</span>(<span class="title">id</span>,<span class="title">id</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">setJobData</span>(<span class="title">dataMap</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">build</span>()</span>;</span><br><span class="line">        <span class="comment">//trigger</span></span><br><span class="line">        Trigger trigger = TriggerBuilder.newTrigger()</span><br><span class="line">                .withIdentity(id,id)</span><br><span class="line">                .startAt(startDate)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="comment">//写入数据库</span></span><br><span class="line">        PtpMsmTask job = PtpMsmTask.builder()</span><br><span class="line">                .jobName(id)</span><br><span class="line">                .parameter(parameter)</span><br><span class="line">                .executeDate(startDate)</span><br><span class="line">                .status(TaskStatusEnum.NOT_PERFORME.getType())</span><br><span class="line">                .type(TaskTypeEnum.LATER.getType())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">long</span> count = repository.insert(job);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"任务&#123;&#125;写入数据库失败，任务不执行"</span>, job);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            scheduler.scheduleJob(jobDetail,trigger);</span><br><span class="line">            log.info(<span class="string">"job---&#123;&#125;加入至schedule"</span>,id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加立即执行的任务</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(String parameter)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置一个标识符</span></span><br><span class="line">        String id = UUID.randomUUID().toString();</span><br><span class="line">        <span class="comment">//设置传入job的参数</span></span><br><span class="line">        JobDataMap dataMap = <span class="keyword">new</span> JobDataMap();</span><br><span class="line">        dataMap.put(<span class="string">"parameter"</span>, parameter);</span><br><span class="line">        <span class="comment">//jobDetail</span></span><br><span class="line">        JobDetail jobDetail = JobBuilder.newJob(MyJob<span class="class">.<span class="keyword">class</span>).<span class="title">withIdentity</span>(<span class="title">id</span>,<span class="title">id</span>).<span class="title">setJobData</span>(<span class="title">dataMap</span>).<span class="title">build</span>()</span>;</span><br><span class="line">        <span class="comment">//trigger</span></span><br><span class="line">        Trigger trigger = TriggerBuilder.newTrigger().withIdentity(id,id).startNow().build();</span><br><span class="line">        <span class="comment">//写入数据库</span></span><br><span class="line">        PtpMsmTask job = PtpMsmTask.builder()</span><br><span class="line">                .jobName(id)</span><br><span class="line">                .parameter(parameter)</span><br><span class="line">                .executeDate(<span class="keyword">new</span> Date())</span><br><span class="line">                .status(TaskStatusEnum.NOT_PERFORME.getType())</span><br><span class="line">                .type(TaskTypeEnum.NOW.getType())</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">long</span> count = repository.insert(job);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            log.info(<span class="string">"任务&#123;&#125;写入数据库失败，任务不执行"</span>, job);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            scheduler.scheduleJob(jobDetail,trigger);</span><br><span class="line">            log.info(<span class="string">"job---&#123;&#125;加入至schedule"</span>,id);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="controller层-1"><a href="#controller层-1" class="headerlink" title="controller层"></a>controller层</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuartzController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> QuartzService service;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Scheduler scheduler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加一个任务，60s后执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter 传入的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/add/&#123;parameter&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">add</span><span class="params">(@PathVariable(value = <span class="string">"parameter"</span>)</span> String parameter) </span>&#123;</span><br><span class="line">        <span class="comment">//设置60s后执行</span></span><br><span class="line">        Date now = <span class="keyword">new</span> Date();</span><br><span class="line">        log.info(<span class="string">"现在时间为&#123;&#125;"</span>,now);</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line">        calendar.setTime(now);</span><br><span class="line">        calendar.add(Calendar.SECOND, <span class="number">60</span>);</span><br><span class="line">        <span class="comment">//执行时间</span></span><br><span class="line">        Date startDate = calendar.getTime();</span><br><span class="line">        log.info(<span class="string">"任务执行的时间为&#123;&#125;"</span>, startDate);</span><br><span class="line">        service.addJob(parameter, startDate);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"add successfully"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 得到当前任务执行的列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/job"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List <span class="title">job</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (String groupName : scheduler.getJobGroupNames()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (JobKey jobKey : scheduler.getJobKeys(GroupMatcher.jobGroupEquals(groupName))) &#123;</span><br><span class="line">                    String jobName = jobKey.getName();</span><br><span class="line">                    String jobGroup = jobKey.getGroup();</span><br><span class="line">                    <span class="comment">//get trigger</span></span><br><span class="line">                    List&lt;Trigger&gt; triggers = (List&lt;Trigger&gt;) scheduler.getTriggersOfJob(jobKey);</span><br><span class="line">                    Date nextFireTime = triggers.get(<span class="number">0</span>).getNextFireTime();</span><br><span class="line">                    res.add(<span class="string">"[jobName] : "</span> + jobName + <span class="string">",[groupName] : "</span></span><br><span class="line">                            + jobGroup + <span class="string">" - "</span> + nextFireTime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SchedulerException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加自定义数量的job</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count job的数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"test/&#123;count&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(@PathVariable(value = <span class="string">"count"</span>)</span> <span class="keyword">int</span> count) </span>&#123;</span><br><span class="line">        Calendar calendar = Calendar.getInstance();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            calendar.setTime(<span class="keyword">new</span> Date());</span><br><span class="line">            calendar.add(Calendar.SECOND, <span class="number">10</span>);</span><br><span class="line">            service.addJob(Integer.toString(i),calendar.getTime());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="两种方案比较"><a href="#两种方案比较" class="headerlink" title="两种方案比较"></a>两种方案比较</h1><h2 id="quartz原生持久化"><a href="#quartz原生持久化" class="headerlink" title="quartz原生持久化"></a>quartz原生持久化</h2><ol><li><p>优点</p><ul><li>支持集群</li><li>原生支持，不需要写SQL</li><li>任务恢复更有保证</li></ul></li><li><p>缺点</p><ul><li><p>需要是一张表，且表与表之间存在外键关联</p></li><li><p>运行速度的快慢取决于连接数据库的快慢</p></li><li><p>历史记录需要自己重新建表记录</p></li><li><p>如果数据库中存在大量过去未执行的任务（假设有5w条），当程序重启时会马上执行过期的任务，此时会出现一个我暂时无法解决的异常:( ，异常参考<a href="https://dzone.com/articles/quartz-scheduler-misfire" target="_blank" rel="noopener">链接</a> </p></li><li><pre><code>Handling the first 20 triggers that missed their scheduled fire-time.  More misfired triggers remain to be processed.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 自定义持久化</span><br><span class="line"></span><br><span class="line">1. 优点</span><br><span class="line"></span><br><span class="line">   - 可控性较高、较为简单</span><br><span class="line">   - 数据库只需要增加一张表</span><br><span class="line"></span><br><span class="line">   ```mysql</span><br><span class="line">   CREATE TABLE `PTP_MSM_TASK` (</span><br><span class="line">     `ID` int(11) NOT NULL AUTO_INCREMENT COMMENT &apos;任务id&apos;,</span><br><span class="line">     `JOB_NAME` varchar(40) DEFAULT NULL COMMENT &apos;任务名&apos;,</span><br><span class="line">     `PARAMETER` varchar(2000) DEFAULT NULL COMMENT &apos;传入参数&apos;,</span><br><span class="line">     `EXECUTE_DATE` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &apos;执行日期&apos;,</span><br><span class="line">     `STATUS` int(11) NOT NULL COMMENT &apos;执行状态，0--未执行，1--执行成功，2--执行失败&apos;,</span><br><span class="line">     `CRON` varchar(40) DEFAULT NULL COMMENT &apos;cron表达式&apos;,</span><br><span class="line">     `TYPE` INT DEFAULT 0 NOT NULL COMMENT &apos;任务执行类型，0--立即执行，1--延时执行一次，2--利用cron表达式执行&apos;</span><br><span class="line">     PRIMARY KEY (`ID`)</span><br><span class="line">   ) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT=&apos;任务表&apos;;</span><br></pre></td></tr></table></figure></code></pre></li></ul></li></ol><ol start="2"><li><p>缺点</p><ul><li>不支持集群（可以自己添加支持）</li><li>运行速度的快慢取决于连接数据库的快慢</li><li>因为只有一张表，记录的信息较少，如果系统挂了可能有些任务无法恢复</li></ul></li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.quartz-scheduler.org/documentation/quartz-2.x/tutorials/tutorial-lesson-09.html" target="_blank" rel="noopener">http://www.quartz-scheduler.org/documentation/quartz-2.x/tutorials/tutorial-lesson-09.html</a></p><p><a href="https://juejin.im/post/5abb7af36fb9a028cb2dae9a" target="_blank" rel="noopener">https://juejin.im/post/5abb7af36fb9a028cb2dae9a</a></p><blockquote><p>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Quartz </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于ES倒排索引v6.2.4的一些小坑</title>
      <link href="/2018/04/29/ElasticSearch%E8%80%81%E7%89%88%E6%9C%AC%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
      <url>/2018/04/29/ElasticSearch%E8%80%81%E7%89%88%E6%9C%AC%E9%94%99%E8%AF%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<p>刚开始学习，项目中准备用<del>~</del></p><a id="more"></a><h2 id="Q1"><a href="#Q1" class="headerlink" title="Q1"></a>Q1</h2><blockquote><p>no [query] registered for [filtered]</p></blockquote><p>Stack Overflow上有大兄弟已经给出了解答</p><blockquote><p>The <code>filtered</code> query has been deprecated and removed in ES 5.0. You should now use the bool/must/filter query instead.</p></blockquote><p>so</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;query&quot; : &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;must&quot;: &#123;</span><br><span class="line">                &quot;match&quot; : &#123;</span><br><span class="line">                    &quot;last_name&quot; : &quot;smith&quot; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;filter&quot;: &#123;</span><br><span class="line">                &quot;range&quot; : &#123;</span><br><span class="line">                    &quot;age&quot; : &#123; &quot;gt&quot; : 30 &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Q2"><a href="#Q2" class="headerlink" title="Q2"></a>Q2</h2><blockquote><p>Fielddata is disabled on text fields by default. Set <code>fielddata=true</code> on [<code>your_field_name</code>] in order to load fielddata in memory by uninverting the inverted index. Note that this can however use significant memory.</p></blockquote><p>这个错误是因为ES官方默认关闭了fielddata，原因是fielddata会耗尽很多的heap堆内存，特别是加载high cardinality text 的字段。一旦fielddata被加载进堆内存，它将会在段的整个生命周期都存在。同时，加载fielddata也是代价高昂的，它将导致用户操作时存在停顿。这就是fielddata为什么默认关闭的原因。</p><p><strong>解决方案</strong></p><p>解决的问题就转化为了如何开启fielddata参数？</p><p>下面是官方文档给的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">PUT my_index/_mapping/_doc</span><br><span class="line">&#123;</span><br><span class="line">  &quot;properties&quot;: &#123;</span><br><span class="line">    &quot;my_field&quot;: &#123; </span><br><span class="line">      &quot;type&quot;:     &quot;text&quot;,</span><br><span class="line">      &quot;fielddata&quot;: true</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>套用之前的官网例子上的URL就是</p><p><code>PUT /megacorp/_mapping/employee</code></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://stackoverflow.com/questions/40519806/no-query-registered-for-filtered" target="_blank" rel="noopener">https://stackoverflow.com/questions/40519806/no-query-registered-for-filtered</a></p><p><a href="https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/index.html" target="_blank" rel="noopener">https://elasticsearch.cn/book/elasticsearch_definitive_guide_2.x/index.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 查询 </tag>
            
            <tag> ES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程池【未完】</title>
      <link href="/2018/04/19/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2018/04/19/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p>好几次被问到关于线程池的问题，却答不上来，有一种最熟悉的陌生人的感觉。</p><a id="more"></a><h1 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h1><blockquote><p><strong>线程池</strong>（英语：thread pool）：一种<a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">线程</a>使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。线程池不仅能够保证内核的充分利用，还能防止过分调度。可用线程数量应该取决于可用的并发处理器、处理器内核、内存、网络sockets等的数量。 例如，线程数一般取cpu数量+2比较合适，线程数过多会导致额外的线程切换开销。</p></blockquote><h1 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h1><ul><li><p>复用线程，降低系统开销。</p><p>众所周知，创建/销毁一个线程是需要消耗系统资源的，特别是频繁的创建/销毁。如果当创建一个线程的时间为T1，销毁为T2，线程执行任务的时间为T3，此时T1+T2&gt;T3，那么对于程序来说，这是一种很不划算的方式来执行这项任务。而线程池可以将创建后的线程保存下来，当下次再使用时就不需要重新创建。</p></li><li><p>管理线程。</p><p>创建众多的线程如果没有恰当的管理与调度，那么线程就会混乱。线程池提供了对线程的简单管理和一些执行策略，同时对于任务，有专门的任务队列进行管理。</p></li><li><p>控制并发。</p><p>多线程的情况下，可能会出现对共享资源竞争而产生死锁的情况，此时线程池能够控制并发数，尽可能避免因竞争资源而导致死锁的情况</p></li></ul><h1 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a>ThreadPoolExecutor类</h1><p>该类是最核心的一个类，<code>Executors</code>类中的大多简单工厂方法都是返回ThreadPoolExecutor的实例，只不过对应了不同构造参数，这个待会再讲。</p><p>先看下ThreadPoolExecutor类中的重要变量</p><h2 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Core pool size is the minimum number of workers to keep alive</span></span><br><span class="line"><span class="comment">    * (and not allow to time out etc) unless allowCoreThreadTimeOut</span></span><br><span class="line"><span class="comment">    * is set, in which case the minimum is zero.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment">    * if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br></pre></td></tr></table></figure><p>核心池大小。</p><p>从注释可以看出，Core pool size是线程池中（核心）线程的数量，这些线程即使是空闲的，也不会被销毁，除非</p><p><code>allowCoreThreadTimeOut</code>这个字段被设置</p><p>这里额外扩展下<code>volatile</code>这个关键字</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><blockquote><p>当一个变量被声明为volatile类型后，编译期与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器看不到的地方，因此在读取volatile变量时总会返回最新写入的值。</p><p>但是，</p><p><strong>volatile无法解决多线程下写入导致数据不一致的问题</strong>，volatile只能确保可见性。</p><p>那什么是<strong>可见性</strong>呢？</p><blockquote><p>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></blockquote></blockquote><h2 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Maximum pool size. Note that the actual maximum is internally</span></span><br><span class="line"><span class="comment"> * bounded by CAPACITY.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br></pre></td></tr></table></figure><p>线程池允许的最大线程数。但实际上不能超过线程自定义的CAPACITY</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Timeout in nanoseconds for idle threads waiting for work.</span></span><br><span class="line"><span class="comment"> * Threads use this timeout when there are more than corePoolSize</span></span><br><span class="line"><span class="comment"> * present or if allowCoreThreadTimeOut. Otherwise they wait</span></span><br><span class="line"><span class="comment"> * forever for new work.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br></pre></td></tr></table></figure><p>空闲线程的超时时间。</p><p>当线程数量大于corePoolSize或者allowCoreThreadTimeOut为true时，线程使用这个超时时间来终止自己。否则，这些线程将一直等待到有work为止。</p><h2 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The queue used for holding tasks and handing off to worker</span></span><br><span class="line"><span class="comment"> * threads.  We do not require that workQueue.poll() returning</span></span><br><span class="line"><span class="comment"> * null necessarily means that workQueue.isEmpty(), so rely</span></span><br><span class="line"><span class="comment"> * solely on isEmpty to see if the queue is empty (which we must</span></span><br><span class="line"><span class="comment"> * do for example when deciding whether to transition from</span></span><br><span class="line"><span class="comment"> * SHUTDOWN to TIDYING).  This accommodates special-purpose</span></span><br><span class="line"><span class="comment"> * queues such as DelayQueues for which poll() is allowed to</span></span><br><span class="line"><span class="comment"> * return null even if it may later return non-null when delays</span></span><br><span class="line"><span class="comment"> * expire.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br></pre></td></tr></table></figure><p>工作队列。</p><p>这个队列用于执行任务之前保留任务。即用来存储等待执行的任务。</p><ol><li><p>ArrayBlockingQueue：　　</p><p>基于数组结构的有界队列，此队列按FIFO原则对任务进行排序。如果队列满了还有任务进来，则调用拒绝策略。</p></li><li><p>LinkedBlockingQueue：　 </p><p>基于链表结构的无界队列，此队列按FIFO原则对任务进行排序。因为它是无界的，根本不会满，所以采用此队列后线程池将忽略拒绝策略（handler）参数；同时还将忽略最大线程数（maximumPoolSize）等参数。</p></li><li><p>SynchronousQueue：　　</p><p> 直接将任务提交给线程而不是将它加入到队列，实际上此队列是空的。每个插入的操作必须等到另一个调用移除的操作；如果新任务来了线程池没有任何可用线程处理的话，则调用拒绝策略。其实要是把maximumPoolSize设置成无界（Integer.MAX_VALUE）的，加上SynchronousQueue队列，就等同于Executors.newCachedThreadPool()。</p></li><li><p>PriorityBlockingQueue：　</p><p>具有优先级的队列的有界队列，可以自定义优先级；默认是按自然排序，可能很多场合并不合适。</p></li></ol><h2 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory for new threads. All threads are created using this</span></span><br><span class="line"><span class="comment"> * factory (via method addWorker).  All callers must be prepared</span></span><br><span class="line"><span class="comment"> * for addWorker to fail, which may reflect a system or user's</span></span><br><span class="line"><span class="comment"> * policy limiting the number of threads.  Even though it is not</span></span><br><span class="line"><span class="comment"> * treated as an error, failure to create threads may result in</span></span><br><span class="line"><span class="comment"> * new tasks being rejected or existing ones remaining stuck in</span></span><br><span class="line"><span class="comment"> * the queue.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We go further and preserve pool invariants even in the face of</span></span><br><span class="line"><span class="comment"> * errors such as OutOfMemoryError, that might be thrown while</span></span><br><span class="line"><span class="comment"> * trying to create threads.  Such errors are rather common due to</span></span><br><span class="line"><span class="comment"> * the need to allocate a native stack in Thread.start, and users</span></span><br><span class="line"><span class="comment"> * will want to perform clean pool shutdown to clean up.  There</span></span><br><span class="line"><span class="comment"> * will likely be enough memory available for the cleanup code to</span></span><br><span class="line"><span class="comment"> * complete without encountering yet another OutOfMemoryError.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br></pre></td></tr></table></figure><p>线程工厂。</p><p>所有的线程都从这个工厂中产生</p><h1 id="Executors类"><a href="#Executors类" class="headerlink" title="Executors类"></a>Executors类</h1><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://liuzho.github.io/2017/04/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E6%88%96%E8%AE%B8%E5%B0%B1%E5%A4%9F%E4%BA%86" target="_blank" rel="noopener">https://liuzho.github.io/2017/04/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E6%88%96%E8%AE%B8%E5%B0%B1%E5%A4%9F%E4%BA%86</a></p><p><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%BA%BF%E7%A8%8B%E6%B1%A0</a></p><p><a href="http://www.cnblogs.com/nayitian/p/3262031.html" target="_blank" rel="noopener">http://www.cnblogs.com/nayitian/p/3262031.html</a></p><blockquote><p>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 线程池 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java注解【未完】</title>
      <link href="/2018/04/17/Java%E6%B3%A8%E8%A7%A3/"/>
      <url>/2018/04/17/Java%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Annotation其实是一种接口。通过Java的反射机制相关的API来访问Annotation信息。相关类（框架或工具中的类即使用注解的类）根据这些信息来决定如何使用该程序元素或改变它们的行为。</p></blockquote><a id="more"></a><h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><blockquote><p>被该注解修饰的类会生成到Javadoc中</p></blockquote><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><blockquote><p>@Retention定义了该Annotation被保留的时间长短。</p><ul><li>RetentionPolicy.SOURCE<br>源码级别，注解只存在源码中。主要是与编译器交互，用于代码检测。如@Override，@SuppressWarnings。额外效率损耗发生在编译时。</li><li>RetentionPolicy.CLASS<br>字节码级别，注解存在于源码与字节码文件中。主要用于编译时生成额外的文件，如XML，Java文件等，但运行时无法获得。这个级别需要添加JVM加载时候的代理，使用代理来动态修改字节码文件。</li><li>RetentionPolicy.RUNTIME<br>运行时级别，注解存在于源码，字节码与Java虚拟机中。主要用于运行时反射相关信息</li></ul></blockquote><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><blockquote><p>说明了该Annotation所修饰的对象范围</p></blockquote><h4 id="ElementType-value"><a href="#ElementType-value" class="headerlink" title="ElementType[] value();"></a>ElementType[] value();</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">        <span class="comment">/** Class, interface (including annotation type), or enum declaration */</span></span><br><span class="line">        TYPE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Field declaration (includes enum constants) */</span></span><br><span class="line">        FIELD,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Method declaration */</span></span><br><span class="line">        METHOD,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Formal parameter declaration */</span></span><br><span class="line">        PARAMETER,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Constructor declaration */</span></span><br><span class="line">        CONSTRUCTOR,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Local variable declaration */</span></span><br><span class="line">        LOCAL_VARIABLE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Annotation type declaration */</span></span><br><span class="line">        ANNOTATION_TYPE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Package declaration */</span></span><br><span class="line">        PACKAGE,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Type parameter declaration</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TYPE_PARAMETER,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Use of a type</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        TYPE_USE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    jdk1.8中共有10个取值<br>​    - TYPE：用来修饰类、接口（包括注解类型）和枚举类型<br>​    - FIELD：用来修饰域（包含枚举常量），域相当于类里的成员变量<br>​    - METHOD：用来修饰方法<br>​    - PARAMETER：用来修饰形式参数<br>​    - CONSTRUCTOR：用来修饰构造器<br>​    - LOCAL_VARIABLE：用来修饰局部变量<br>​    - ANNOTATION_TYPE：用来修饰注解类型<br>​    - PACKAGE：用来修饰包<br>​    - TYPE_PARAMETER（@since 1.8）：用来修饰参数类型<br>​    - TYPE_USE（@since 1.8）：可以用于标注任意类型(不包括class)</p><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><blockquote><p>阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类</p></blockquote><h2 id="标准注解"><a href="#标准注解" class="headerlink" title="标准注解"></a>标准注解</h2><ul><li>@Override：表示被修饰的方法覆盖了父类的方法</li><li>@Deprecated：表示被修饰的类或类成员已经在当前jdk版本被遗弃了，通常来说使用这些是危险的，也可能是因为出现了其他更好的解决方案。</li><li>@SuppressWarnings：表示告诉Java编译器关闭对类、方法及成员变量的警告。</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://juejin.im/entry/57e496fd7db2a20063a24a3a" target="_blank" rel="noopener">https://juejin.im/entry/57e496fd7db2a20063a24a3a</a><br><a href="http://josh-persistence.iteye.com/blog/2226493" target="_blank" rel="noopener">http://josh-persistence.iteye.com/blog/2226493</a></p><blockquote><p>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈GC</title>
      <link href="/2018/04/17/%E6%B5%85%E8%B0%88GC/"/>
      <url>/2018/04/17/%E6%B5%85%E8%B0%88GC/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>垃圾回收</strong>（英语：Garbage Collection），在计算机科学中，缩写为GC是一种自动的<a href="https://zh.wikipedia.org/wiki/%E8%A8%98%E6%86%B6%E9%AB%94%E7%AE%A1%E7%90%86" target="_blank" rel="noopener">存储器管理</a>机制。当一个电脑上的动态存储器不再需要时，就应该予以释放，以让出存储器，这种存储器资源管理，称为<strong>垃圾回收</strong>。垃圾回收器可以让程序员减轻许多负担，也减少程序员犯错的机会。垃圾回收最早起源于<a href="https://zh.wikipedia.org/wiki/LISP" target="_blank" rel="noopener">LISP</a>语言。目前许多语言如<a href="https://zh.wikipedia.org/wiki/Smalltalk" target="_blank" rel="noopener">Smalltalk</a>、<a href="https://zh.wikipedia.org/wiki/Java" target="_blank" rel="noopener">Java</a>、<a href="https://zh.wikipedia.org/wiki/C_Sharp" target="_blank" rel="noopener">C#</a>和<a href="https://zh.wikipedia.org/wiki/D%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener">D语言</a>都支持垃圾回收器。</p></blockquote><a id="more"></a><h1 id="什么对象需要垃圾回收？"><a href="#什么对象需要垃圾回收？" class="headerlink" title="什么对象需要垃圾回收？"></a>什么对象需要垃圾回收？</h1><p>垃圾回收，如何判定哪些对象需要回收呢？</p><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><blockquote><p>最早期的垃圾回收实现方法，通过对数据存储的物理空间附加多一个计数器空间，当有其他数据与其相关时则加一，反之相关解除时减一，定期检查各储存对象的计数器，为零的话则认为已经被抛弃而将其所占物理空间回收。是最简单的实现，但存在无法回收循环引用的存储对象的缺陷。</p></blockquote><p>如下图：</p><p><img src="https://i.loli.net/2018/04/17/5ad60827157b3.png" alt="互相引用"></p><p>（图片来自<a href="https://blog.csdn.net/justloveyou_" target="_blank" rel="noopener">书呆子Rico</a>）</p><p>OK，既然不能用这种方式解决，那么就出现了可达性分析的算法。</p><h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><blockquote><p>近现代的垃圾回收实现方法，通过定期对若干根储存对象开始遍历，对整个程序所拥有的储存空间查找与之相关的存储对象和没相关的存储对象进行标记，然后将没相关的存储对象所占物理空间回收。</p></blockquote><p>什么意思呢，就是通过一系列的名为”GC  Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连，即从GC Roots到这个对象不可达，则证明此对象是不可用的。如图：</p><p><img src="https://pic3.zhimg.com/80/cb06b4bd6d62cf310b7f3014ab5cb2fc_hd.jpg" alt="可达性分析"></p><p>左边的对象都是存活的，右边的都是可以回收的。（左边从上往下第一个对象为GC ROOTS）</p><p>那么，继续提出问题，什么对象可以作为GC ROOTS？</p><ol><li>虚拟机栈（栈帧中的本地变量表）中的引用的对象</li><li>方法区中的类静态属性引用的对象</li><li>方法区中的常量引用的对象</li><li>本地方法栈中JNI（Native方法）的引用对象</li></ol><h1 id="JVM如何进行垃圾回收？"><a href="#JVM如何进行垃圾回收？" class="headerlink" title="JVM如何进行垃圾回收？"></a>JVM如何进行垃圾回收？</h1><p>OK，现在JVM知道了哪些对象需要回收了，那么怎么去回收呢？</p><h2 id="四种垃圾回收算法"><a href="#四种垃圾回收算法" class="headerlink" title="四种垃圾回收算法"></a>四种垃圾回收算法</h2><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><blockquote><p><strong>“复制算法”将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</strong>这种算法适用于对象存活率低的场景，比如新生代。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。</p></blockquote><p>如图所示：</p><p><img src="http://www.ityouknow.com/assets/images/2017/jvm/gc_garbage2.png" alt="复制算法"></p><p>一般来说，JVM肯定不是只用一半内存，否则这对于内存的使用率来说实在过于低下。经研究发现，新生代中的对象每次回收都基本只有10%存活，需要复制的对象较少，所以，通常情况下，JVM会将新生代内存分为Eden区和两个survivor区（<a href="https://qianhangkang.github.io/2018/04/13/%E6%B5%85%E8%B0%88JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/#JVM内存模型" target="_blank" rel="noopener">浅谈JVM内存模型</a>），Eden区和两个survivor区的比例为8：1，也就是说新生代的可用内存为整个新生代的90%，新生代内存的利用率达到了90%，这远远超过了之前的50%。</p><h3 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h3><blockquote><p>“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p></blockquote><p>主要缺点：</p><ol><li>效率问题，标记和清除过程的效率都不高</li><li>空间问题，标记清除之后会产生大量不连续的内存碎片，导致之后需要分配较大对象时无法找到足够的连续内存而不得不提前触发GC，而GC的开销是很大的。</li></ol><p>标记清楚如下图所示：</p><p><img src="http://www.ityouknow.com/assets/images/2017/jvm/gc_garbage1.png" alt="标记清除算法"></p><h3 id="标记整理"><a href="#标记整理" class="headerlink" title="标记整理"></a>标记整理</h3><blockquote><p> “标记整理”算法与“标记清除”算法非常相似，它也是分为两个阶段：<strong>标记和整理</strong>。首先标记出所有需要回收的对象，然后回收期间，会让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p></blockquote><p>如下图所示</p><p><img src="http://www.ityouknow.com/assets/images/2017/jvm/gc_garbage3.png" alt="标记整理算法"></p><h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><blockquote><p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p><p>“分代收集”算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p></blockquote><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><blockquote><p>串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。新生代、老年代使用串行回收；新生代复制算法、老年代标记-压缩；垃圾收集的过程中会Stop The World（服务暂停）</p></blockquote><p><img src="http://www.ityouknow.com/assets/images/2017/jvm/gc_garbage4.png" alt="Serial收集器"></p><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><blockquote><p>ParNew收集器其实就是Serial收集器的多线程版本。新生代并行，老年代串行；新生代复制算法、老年代标记-整理</p></blockquote><p><img src="http://www.ityouknow.com/assets/images/2017/jvm/gc_garbage5.png" alt="ParNew收集器"></p><h3 id="Parallel收集器"><a href="#Parallel收集器" class="headerlink" title="Parallel收集器"></a>Parallel收集器</h3><blockquote><p>Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。可以通过参数来打开自适应调节策略，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或最大的吞吐量；也可以通过参数控制GC的时间不大于多少毫秒或者比例；新生代复制算法、老年代标记-整理</p></blockquote><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><blockquote><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法。这个收集器是在JDK 1.6中才开始提供</p></blockquote><h3 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h3><blockquote><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。</p><p>从名字（包含“Mark Sweep”）上就可以看出CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤，包括：</p><ul><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ul><p>其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>由于整个过程中耗时最长的并发标记和并发清除过程中，收集器线程都可以与用户线程一起工作，所以总体上来说，CMS收集器的内存回收过程是与用户线程一起并发地执行。</p></blockquote><p>优点：</p><ol><li>并发收集</li><li>低停顿</li></ol><p>缺点：</p><ol><li><strong>对CPU资源非常敏感。</strong>面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个时（比如2个），CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。</li><li><strong>无法处理浮动垃圾（Floating Garbage）</strong>。可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生。这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就被称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。</li><li><strong>标记-清除算法导致的空间碎片</strong> 。CMS是一款基于“标记-清除”算法实现的收集器，这意味着收集结束时会有大量空间碎片产生。空间碎片过多时，将会给大对象分配带来很大麻烦，往往出现老年代空间剩余，但无法找到足够大连续空间来分配当前对象。因此，为了解决空间浪费问题，CMS回收器不再采用简单的指针指向一块可用堆空间来为下次对象分配使用。而是把一些未分配的空间汇总成一个列表，当JVM分配对象空间的时候，会搜索这个列表找到足够大的空间来存放这个对象。</li></ol><p><img src="http://dl.iteye.com/upload/attachment/612577/2b525609-ce63-3a42-bf19-b2fbcd42f26c.png" alt="CMS收集器"></p><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><blockquote><p>Garbage-First（G1）收集器是一种服务器式垃圾收集器，针对具有<strong>大型内存的多处理器机器</strong>。 它以高概率满足垃圾收集（GC）暂停时间目标，同时实现高吞吐量。垃圾收集器在Oracle JDK 7u4和更高版本中得到完全支持。</p><p>G1垃圾收集算法主要应用在多CPU大内存的服务中，在满足高吞吐量的同时，竟可能的满足垃圾回收时的暂停时间，该设计主要针对如下应用场景：</p><ul><li>垃圾收集线程和应用线程并发执行，和CMS一样</li><li>空闲内存压缩时避免冗长的暂停时间</li><li>应用需要更多可预测的GC暂停时间</li><li>不希望牺牲太多的吞吐性能</li><li>不需要很大的Java堆 </li></ul></blockquote><p>具体的回收方式参见<a href="http://www.importnew.com/27793.html" target="_blank" rel="noopener">这篇文章</a>，讲的非常详细，很nice。</p><h1 id="JVM在什么时候垃圾回收？"><a href="#JVM在什么时候垃圾回收？" class="headerlink" title="JVM在什么时候垃圾回收？"></a>JVM在什么时候垃圾回收？</h1><h2 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h2><p>如下为System.gc()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Indicates to the VM that it would be a good time to run the</span></span><br><span class="line"><span class="comment"> * garbage collector. Note that this is a hint only. There is no guarantee</span></span><br><span class="line"><span class="comment"> * that the garbage collector will actually be run.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> shouldRunGC;</span><br><span class="line">    <span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">        shouldRunGC = justRanFinalization;</span><br><span class="line">        <span class="keyword">if</span> (shouldRunGC) &#123;</span><br><span class="line">            justRanFinalization = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            runGC = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldRunGC) &#123;</span><br><span class="line">        Runtime.getRuntime().gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可见，当justRanFinalization为true时，系统会在调用System.gc()时发生GC。这里只是为了强调System.gc()并不一定会强制发生gc，类似finalize方法。</p><h2 id="系统自动GC"><a href="#系统自动GC" class="headerlink" title="系统自动GC"></a>系统自动GC</h2><p>当运行时某些区域的内存不足时系统自动进行垃圾回收</p><p>参考自自<a href="https://www.zhihu.com/question/41922036" target="_blank" rel="noopener">R神的解释</a>：</p><blockquote><ol><li>young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。</li><li>full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；或者System.gc()、heap dump带GC，默认也是触发full GC。</li></ol></blockquote><p>总结一下就是系统自动回收主要看Eden区和old区的内存使用情况，不够了就触发相应的GC。</p><p>这里对GC的种类做一个分类：</p><blockquote><p>Partial GC：并不收集整个GC堆的模式</p><ul><li>Young GC：只收集young gen的GC</li><li>Old GC：只收集old gen的GC。只有CMS的concurrent collection是这个模式</li><li>Mixed GC：收集整个young gen以及部分old gen的GC。只有G1有这个模式</li></ul><p>Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。</p></blockquote><p><strong>Major GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old GC。</strong></p><p>因此更正下之前写的<a href="https://qianhangkang.github.io/2018/04/13/%E6%B5%85%E8%B0%88JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/#新生代" target="_blank" rel="noopener">浅谈JVM内存模型与对象创建</a>的错误（已修正）…</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://zh.wikipedia.org/wiki/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6_(%E8%A8%88%E7%AE%97%E6%A9%9F%E7%A7%91%E5%AD%B8)" target="_blank" rel="noopener">维基百科（垃圾回收）</a></p><p><a href="https://blog.csdn.net/justloveyou_/article/details/71216049" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/71216049</a></p><p><a href="https://www.zhihu.com/question/35164211" target="_blank" rel="noopener">https://www.zhihu.com/question/35164211</a></p><p><a href="http://softbeta.iteye.com/blog/1315103" target="_blank" rel="noopener">http://softbeta.iteye.com/blog/1315103</a></p><p><a href="https://crowhawk.github.io/2017/08/15/jvm_3/" target="_blank" rel="noopener">https://crowhawk.github.io/2017/08/15/jvm_3/</a></p><p><a href="http://www.importnew.com/27793.html" target="_blank" rel="noopener">http://www.importnew.com/27793.html</a></p><p><a href="https://www.zhihu.com/question/41922036" target="_blank" rel="noopener">https://www.zhihu.com/question/41922036</a></p><blockquote><p>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈JVM内存区域与对象创建过程</title>
      <link href="/2018/04/13/%E6%B5%85%E8%B0%88JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/04/13/%E6%B5%85%E8%B0%88JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<blockquote><p>上次面试本以为熟悉了这块内容，但实际上自己还是对这块知识的概念挺模糊的。</p></blockquote><a id="more"></a><h1 id="JVM内存模型"><a href="#JVM内存模型" class="headerlink" title="JVM内存模型"></a>JVM内存模型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据。这些区域都有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。Java虚拟机所管理的内存如下图所示。</p></blockquote><p><img src="https://i.loli.net/2018/04/13/5ad051fd3f6c5.jpg" alt="JVM内存模型_看图王.jpg"></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><blockquote><p>是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p><p>由于Java虚拟机的多线程是通过线程轮流切换并分配处理器的执行时间的方式来实现的，在任何一个确定的时间，一个处理器（对于多核处理器来说是一个内核）都只会执行一个线程中的指令。因此，<strong>为了线程切换后能恢复到正确的执行位置</strong>，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，因此这块内存区域是<strong>“线程私有”</strong>的。</p></blockquote><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><blockquote><p>与程序计数器一样，虚拟机栈也是<strong>“线程私有”</strong>的，它的生命周期与线程相同。一般存放了编译期可知的各种基本数据类型、对象引用和returnAddress类型（指向了一条字节码指令的地址）</p></blockquote><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><blockquote><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用Native方法服务。</p></blockquote><h2 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h2><blockquote><p>对于大多数应用来说，Java堆 是Java虚拟机所管理的内存中最大的一块。Java堆是被所有<strong>线程共享</strong>的一块内存区域，在虚拟机启动时创建。主要存放了对象的实例和数组。Java堆也是垃圾回收的主要区域。</p></blockquote><h3 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h3><h4 id="Eden区"><a href="#Eden区" class="headerlink" title="Eden区"></a>Eden区</h4><blockquote><p>对象一般优先再Eden区上分配。如果空间不够会触发一次young GC，如果还不够，那么则触发一次full GC。</p></blockquote><h4 id="From-Survivor与To-Survivor"><a href="#From-Survivor与To-Survivor" class="headerlink" title="From Survivor与To Survivor"></a>From Survivor与To Survivor</h4><blockquote><p>新生代中，每次使用的是Eden区和一个survivor区，这个区就是from survivor。当发生young GC时，会将Eden区和from survivor区中还存活着的对象复制到to survivor区中，然后清理掉Eden区和from survivor区。from survivor区和to survivor都是相对来说的<del>~</del> 一般情况下，HotSpot虚拟机默认的Eden区和一个survivor区的大小比例为8:1。</p></blockquote><h3 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h3><blockquote><p>老年代一般存放的都是经过<strong>分配担保</strong>的大对象和经过数次GC并且经过<strong>动态年龄判定</strong>的对象。</p></blockquote><ul><li>分配担保：写了一半感觉自己解释不清楚，放个<a href="https://www.jianshu.com/p/62c37dc7d638" target="_blank" rel="noopener">链接</a>吧。。。</li><li>动态年龄判定：如果再survivor区中相同年龄所有对象大小的总和大于survivor空间的一半，那么年龄大于等于该年龄的对象就可以直接进入老年代，无需等到MaxTenuringThreshold（默认为15岁，即经过15次GC后才会进入老年代）中要求的年龄。</li></ul><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><blockquote><p>方法区与堆一样，是各个<strong>线程共享</strong>的内存区域，它用于存储<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译期编译后的代码等数据</strong>。</p></blockquote><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><blockquote><p>运行时常量池是方法区的一部分。主要用于存储编译期生成的各种字面量和符号引用。</p></blockquote><h1 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h1><p><img src="https://i.loli.net/2018/04/15/5ad35745e57bc.jpg" alt="JVM内存分配策略"></p><blockquote><p>对象的内存分配，往大方向讲，就是在堆上分配（但也可能经过JIT编译后被拆散为标量类型并简介地栈上分配），对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代，分配的规则并不是百分百固定的，其细节取决于当前使用的是哪一种垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。</p></blockquote><h2 id="对象在Eden区中分配"><a href="#对象在Eden区中分配" class="headerlink" title="对象在Eden区中分配"></a>对象在Eden区中分配</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//VM 参数:-verbose:gc -Xms20m -Xmx20m -Xmn10m  -XX:+PrintGCDetails -XX:+SurvivorRatio=8</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span>*<span class="number">1024</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation1,allocation2,allocation3,allocation4;</span><br><span class="line">        allocation1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        allocation4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码所述，allocation1，allocation2，allocation3都会分配在Eden区中，而在为allocation4分配内存时会发生一次young GC，又因为allocation1，allocation2，allocation3都不需要被回收，to survivor区又放不下，所以他们会被移至老年代，然后allocation4被分配在Eden区。</p><h2 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  </span></span><br><span class="line"><span class="comment">* VM参数：-verbose:gc -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 </span></span><br><span class="line"><span class="comment">* -XX:PretenureSizeThreshold=3145728 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span>*<span class="number">1024</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] allocation;  </span><br><span class="line">　     allocation = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB]; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上述代码所示，allocation会直接分配到老年代中。</p><h1 id="JVM常用控制参数"><a href="#JVM常用控制参数" class="headerlink" title="JVM常用控制参数"></a>JVM常用控制参数</h1><ul><li>-Xms设置堆的最小空间大小。</li><li>-Xmx设置堆的最大空间大小。</li><li>-XX:NewSize设置新生代最小空间大小。</li><li>-XX:MaxNewSize设置新生代最大空间大小。</li><li>-XX:PermSize设置永久代最小空间大小。</li><li>-XX:MaxPermSize设置永久代最大空间大小。</li><li>-Xss设置每个线程的堆栈大小。</li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.ityouknow.com/jvm/2017/08/25/jvm-memory-structure.html" target="_blank" rel="noopener">http://www.ityouknow.com/jvm/2017/08/25/jvm-memory-structure.html</a></p><p><a href="https://juejin.im/post/5a14de6751882555cc417df7" target="_blank" rel="noopener">https://juejin.im/post/5a14de6751882555cc417df7</a></p><blockquote><p>大部分正义感都是虚伪的 聊胜于无   —————————————————————————沃德彭尤·胡某</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 对象创建 </tag>
            
            <tag> 内存模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合类整理</title>
      <link href="/2018/04/12/Java%E9%9B%86%E5%90%88%E7%B1%BB%E6%95%B4%E7%90%86/"/>
      <url>/2018/04/12/Java%E9%9B%86%E5%90%88%E7%B1%BB%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>Java集合类关系挺复杂的，这一次先从集合类开始整理，陆续会整理下线程池、二叉树、JVM和GC</p><a id="more"></a><h1 id="Java集合类图"><a href="#Java集合类图" class="headerlink" title="Java集合类图"></a>Java集合类图</h1><p><img src="https://upload-images.jianshu.io/upload_images/5543739-d576aa33540ee84a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/561" alt="Java集合类图"></p><p>咋一看感觉挺混乱的<del>~</del>但是多看两遍后这个图的结构还是很清晰的</p><h1 id="Collection接口"><a href="#Collection接口" class="headerlink" title="Collection接口"></a>Collection接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Collection接口是集合类接口的root接口。一个集合代表了一组对象，即<strong>elements</strong>。一些集合允许集合重复，一些不允许。一些能进行排序，一些不行。JDK没有&lt;直接&gt;提供任何这个接口的实现，但是它提供了更多的特定的实现这个接口的子接口像Set、List。这个接口通常用于传递集合并在需要最大通用性的情况下对其进行操作。</p><h1 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a>Set接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这个接口实现了Collection接口，并且在JDK9之后多了static &lt;E&gt; Set&lt;E&gt; of(...)方法，该方法返回了一个构造好的final Set</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一个不包含重复元素的集合。更正式的说，这个集合不包含元素e1、e2，使得e1.equals(e2)，同时，该集合最多含有一个null元素。正如它的名字所暗示的，这个接口模拟了数学的集合抽象。</p><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>这个类实现了Set接口，底层是由hash table支持的（事实上就是一个HashMap实例）。它不保证集合迭代的顺序，特别是，它不保证顺序会随着时间保持不变。这个类允许null元素。</p><p>总而言之，在源码中，HashSet类中只有两个变量</p><ol><li><p>private transient HashMap&lt;E,Object&gt; map;</p></li><li><p>static final Object PRESENT = new Object();</p><p>这个PRESENT源码上的注释是<em>Dummy value to associate with an Object in the backing Map</em>，意思就是用来填充HashMap中的value值。这个也可以从源码的add方法中可以看出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedHashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">HashSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>LinkedHashSet是Set接口的hash表和链表的实现，具有可预测迭代顺序。LinkedHashSet与HashSet不同的地方在于LinkedHashSet维护了一个双向列表<code>双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱</code>，它贯穿了所有entries。这个链表定义了迭代的顺序，这个顺序是元素被插入到集合中的顺序。需要注意的是，插入元素的顺序不会收到影响如果一个元素被重新插入到这个集合中。比如，当s.contains(e)在调用之前立即返回true，那么s.add(e)被调用时，元素e会被重新插入到集合s中。</p><h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeSet</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableSet</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>TreeSet实现了NavigableSet接口，NavigableSet接口继承自SortedSet接口。TreeSet是基于TreeMap是实现的。这些元素将会使用Comparable自然排序，或者使用在集合创建时指定的Comparable进行排序，具体取决于使用哪个构造方法。TreeSet保证了基本操作（add,remove,contains）的时间复杂度，为log(n)。</p><h1 id="SortedSet接口"><a href="#SortedSet接口" class="headerlink" title="SortedSet接口"></a>SortedSet接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SortedSet</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Set</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> E&gt; comparator();</span><br><span class="line">    <span class="function">SortedSet&lt;E&gt; <span class="title">subSet</span><span class="params">(E fromElement, E toElement)</span></span>;</span><br><span class="line">    <span class="function">SortedSet&lt;E&gt; <span class="title">headSet</span><span class="params">(E toElement)</span></span>;</span><br><span class="line">    <span class="function">SortedSet&lt;E&gt; <span class="title">tailSet</span><span class="params">(E fromElement)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">last</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Spliterators.IteratorSpliterator&lt;E&gt;(</span><br><span class="line">                <span class="keyword">this</span>, Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Comparator&lt;? <span class="keyword">super</span> E&gt; getComparator() &#123;</span><br><span class="line">                <span class="keyword">return</span> SortedSet.<span class="keyword">this</span>.comparator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SortedSet接口继承自Set接口，它进一步提供了对其中的元素进行完整的排序的功能。这些元素将会使用Comparable自然排序，或者使用在集合创建时指定的Comparable进行排序，具体取决于使用哪个构造方法。（The set’s）该集合的迭代器将会以递增的顺序遍历该集合。同时它提供了额外的操作来进行排序。</p><h1 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a>List接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    Object[] toArray();</span><br><span class="line">    &lt;T&gt; T[] toArray(T[] a);</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//属于List的抽象方法</span></span><br><span class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</span><br><span class="line">    <span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;</span><br><span class="line">    <span class="comment">//以及类似Set接口中的static &lt;E&gt; Set&lt;E&gt; of(...)方法</span></span><br><span class="line">    <span class="keyword">static</span> &lt;E&gt; <span class="function">List&lt;E&gt; <span class="title">of</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>List是一个有序集合接口。使用这个接口的用户可以精确的控制每个元素在列表中的位置。使用者可以通过它们的整数索引（列表中的位置）来访问这些元素，并且可以搜索列表中的元素。</p><p>与集合不同，列表通常允许重复的元素。更加正式的说，列表通常允许一对这样的元素<code>e1，e2，并且e1.equals(e2)</code>，它们通常允许多个null元素如果它们允许的话。有人可能希望通过在用户尝试插入时抛出运行时异常来实现禁止重复的列表，这并不是不可想象的，但我们预计这种用法很少见。</p><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"><span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>,<span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>ArrayList是List接口的可调整大小的实现，底层采用数组。它是实现了所有可选列表的操作，并且允许存放所有的元素，包括null。除了实现List接口外，ArrayList提供了操作数组大小的方法用于内存存储列表。（ArrayList大致与Vector相同，除了ArrayList不是同步的）。</p><h2 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>类似ArrayList，不过它是线程安全的。</p><h3 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Vector</span>&lt;<span class="title">E</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Stack 继承了Vector，是一个先进后出的队列。</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractSequentialList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">Deque</span>&lt;<span class="title">E</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>LinkedList是List和Deque的双向链表的实现。LinkedList实现了所有可选列表的操作，并且允许存放所有的元素，包括null。</p><h1 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a>Map接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Map</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(Object key)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">put</span><span class="params">(K key, V value)</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">remove</span><span class="params">(Object key)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//以及类似Set接口中的static &lt;E&gt; Set&lt;E&gt; of(...)方法</span></span><br><span class="line">    <span class="keyword">static</span> &lt;K, V&gt; <span class="function">Map&lt;K, V&gt; <span class="title">of</span><span class="params">(...)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>这是一个将键与值相匹配的对象。一个map不能包含重复的键；每个键最多可以映射一个值。这个接口代替了一个完全是抽象类而不是一个接口<code>Dictionary</code>的类</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>这个见<a href="../Java集合类整理">链接</a>~</p><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hashtable</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">Dictionary</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>HashTable类实现了一个将键值相匹配的hash表，这个类不允许键或者值为null。为了成功存储和检索哈希表中的对象，用作键的对象必须实现hashCode()和equals()方法。</p><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>TreeMap是基于NavigableMap实现的<strong>红黑树</strong>。这个Map根据其键的Comparable或关键时提供的Comparable来实现自然排序，这取决于使用哪个构造函数。TreeMap保证了containsKey,get, put,remove的时间复杂度为log(n)。</p><p>TreeMap中由4个变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private final Comparator&lt;? super K&gt; comparator;</span><br><span class="line"></span><br><span class="line">private transient Entry&lt;K,V&gt; root;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The number of entries in the tree</span><br><span class="line"> */</span><br><span class="line">private transient int size = 0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * The number of structural modifications to the tree.</span><br><span class="line"> */</span><br><span class="line">private transient int modCount = 0;</span><br></pre></td></tr></table></figure><p><code>Entry&lt;K,V&gt;</code>是一个静态内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       K key;</span><br><span class="line">       V value;</span><br><span class="line">       Entry&lt;K,V&gt; left;</span><br><span class="line">       Entry&lt;K,V&gt; right;</span><br><span class="line">       Entry&lt;K,V&gt; parent;</span><br><span class="line">       <span class="keyword">boolean</span> color = BLACK;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="SortedMap接口"><a href="#SortedMap接口" class="headerlink" title="SortedMap接口"></a>SortedMap接口</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SortedMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; comparator();</span><br><span class="line">    <span class="function">SortedMap&lt;K,V&gt; <span class="title">subMap</span><span class="params">(K fromKey, K toKey)</span></span>;</span><br><span class="line"><span class="function">SortedMap&lt;K,V&gt; <span class="title">headMap</span><span class="params">(K toKey)</span></span>;</span><br><span class="line">    <span class="function">SortedMap&lt;K,V&gt; <span class="title">tailMap</span><span class="params">(K fromKey)</span></span>;</span><br><span class="line">    <span class="function">K <span class="title">firstKey</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">K <span class="title">lastKey</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span></span>;</span><br><span class="line">    Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SortedMap是一个Map，它在键上进一步提供了完整的排序。这个Map根据其键的Comparable或关键时提供的Comparable来实现自然排序，这取决于使用哪个构造函数。</p><p>这个顺序反映了在什么时候迭代有序的map集合视图。同时它额外的提供了几个操作来利用这个排序</p><h1 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h1><h2 id="ArrayList和LinkedList的区别"><a href="#ArrayList和LinkedList的区别" class="headerlink" title="ArrayList和LinkedList的区别"></a>ArrayList和LinkedList的区别</h2><ol><li>ArrayList底层采用的是动态数组，LinkedList采用了双向链表。</li><li>对于访问来说，前者更快；对于增、删来说后者更快。</li></ol><h2 id="HashTable与HashMap的区别"><a href="#HashTable与HashMap的区别" class="headerlink" title="HashTable与HashMap的区别"></a>HashTable与HashMap的区别</h2><ol><li>Hashtable是线程安全的，也就是说是同步的，而HashMap是线程不安全的，不是同步的。</li><li>HashMap允许存在一个为null的key，多个为null的value 。</li><li>hashtable的key和value都不允许为null。</li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://segmentfault.com/a/1190000008522388#articleHeader14" target="_blank" rel="noopener">https://segmentfault.com/a/1190000008522388#articleHeader14</a></p><p><a href="https://www.jianshu.com/p/50e19038e361" target="_blank" rel="noopener">https://www.jianshu.com/p/50e19038e361</a></p><blockquote><p>大部分正义感都是虚伪的 聊胜于无   —————————————沃德彭尤·胡某</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 集合类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记阿里一次电话面试及感想</title>
      <link href="/2018/04/10/%E8%AE%B0%E9%98%BF%E9%87%8C%E4%B8%80%E6%AC%A1%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E5%8F%8A%E6%84%9F%E6%83%B3/"/>
      <url>/2018/04/10/%E8%AE%B0%E9%98%BF%E9%87%8C%E4%B8%80%E6%AC%A1%E7%94%B5%E8%AF%9D%E9%9D%A2%E8%AF%95%E5%8F%8A%E6%84%9F%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<p>今天大概下午五点的时候接到电话，自称是阿里的，问我现在方便吗。当时正吃完饭走在回实验室的路上，于是让他过半个小时再打给我，他说那我五点四十打你吧。紧张的跑回实验室，对着电脑却不知道该看什么，总觉的这也不了解，那也还没掌握，迷糊了半小时。</p><p>五点四十，电话准时响起。</p><a id="more"></a><h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><p>首先是这位老哥的自我介绍（为了最后的彩蛋做准备）</p><h3 id="自我介绍-1"><a href="#自我介绍-1" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>这里就照着之前准备的背了出来。基本上谈谈自己在学校学了什么，做过什么项目（接下来基本上会问到你的项目），以及日常体育运动。</p><hr><h2 id="项目"><a href="#项目" class="headerlink" title="项目"></a>项目</h2><h3 id="简单的介绍下你的项目"><a href="#简单的介绍下你的项目" class="headerlink" title="简单的介绍下你的项目"></a>简单的介绍下你的项目</h3><p>我大二做过一个工具上传下载管理系统的项目。我就简单的跟他介绍说类似网盘，支持断点续传，同时多了一些社交元素在里面，支持点赞、评论、求助等功能。</p><h3 id="讲一讲如何实现断点上传（他问的断点下载，我说我们只实现了断点上传）"><a href="#讲一讲如何实现断点上传（他问的断点下载，我说我们只实现了断点上传）" class="headerlink" title="讲一讲如何实现断点上传（他问的断点下载，我说我们只实现了断点上传）"></a>讲一讲如何实现断点上传（他问的断点下载，我说我们只实现了断点上传）</h3><p>前端用了webuploader框架，每次上传分块之前都会将分块的md5传到服务器查询，如果上传过则忽略，没有则继续上传。全部分片上传完之后会通知服务器拼装分片。</p><p>面试官在这里反复提问了如何实现了断点续传，用了TCP还是UDP还是HTTP的方式。然后还让我重新讲了一遍上传的流程。问我服务器在这期间到底干了那几件事情。</p><h3 id="组装的时候你是如何确定分片的顺序的"><a href="#组装的时候你是如何确定分片的顺序的" class="headerlink" title="组装的时候你是如何确定分片的顺序的"></a>组装的时候你是如何确定分片的顺序的</h3><p>分片上传的时候会将分片的序号一同上传给服务器</p><h3 id="你为什么要用hibernate框架"><a href="#你为什么要用hibernate框架" class="headerlink" title="你为什么要用hibernate框架"></a>你为什么要用hibernate框架</h3><p>这里瞎扯了一些，主要是因为hibernate只在当时的竞赛用过，到现在都忘得差不多了。不过还是跟他说了hibernate有其独特的HQL，更加面向对象。</p><hr><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="Java的基本数据类型有哪些"><a href="#Java的基本数据类型有哪些" class="headerlink" title="Java的基本数据类型有哪些"></a>Java的基本数据类型有哪些</h3><p>char、byte、int、double、float、long、Boolean。我不小心还说了String，面试官马上提示了你，我赶紧说说错了，是char，不是String</p><h3 id="你用过哪些Java的集合类，List和Set有什么区别"><a href="#你用过哪些Java的集合类，List和Set有什么区别" class="headerlink" title="你用过哪些Java的集合类，List和Set有什么区别"></a>你用过哪些Java的集合类，List和Set有什么区别</h3><p>由于之前一直在研究HashMap的源码，于是就回答了在项目中只用HashMap（就是想暗示他问我关于hashmap的问题，结果问了List和Set有啥区别，一下子没想起来，面试官友善的提示了下。）</p><p>List是有序的Collection，允许重复元素；Set无序，不允许重复元素</p><h3 id="Java的值传递和引用传递能说一说嘛"><a href="#Java的值传递和引用传递能说一说嘛" class="headerlink" title="Java的值传递和引用传递能说一说嘛"></a>Java的值传递和引用传递能说一说嘛</h3><p>在Java中是没有引用传递的，只有值传递。而值传递的意思是<strong>传递存储单元中的内容</strong>。</p><ul><li>对于基本数据类型来说，每次传递的时候都会将存储单元中的内容传递进去作为参数，只不过这个参数在内存也分配了空间，他的内容就是传递过来的参数，所以不管你怎么修改这个参数，都与原先传递进来的参数无关了。</li><li>对于对象来说，对象的引用在栈内存中，实例对象的地址在堆内存中。每次传递参数的时候，JVM首先会在栈内存为方法的参数开辟一块空间，然后将对象引用所在的存储单元中的内容传递到这块空间中，而这块内容也就是引用的地址。因此，实际上传递的就是存储单元中的内容，属于值传递。</li></ul><h3 id="有用过多线程嘛，线程创建的方式有哪几种，能说说线程池吗"><a href="#有用过多线程嘛，线程创建的方式有哪几种，能说说线程池吗" class="headerlink" title="有用过多线程嘛，线程创建的方式有哪几种，能说说线程池吗"></a>有用过多线程嘛，线程创建的方式有哪几种，能说说线程池吗</h3><p>这里很老实的说没用过。。。</p><p>线程创建的方式有继承Thread类，实现Runnable接口或Callable接口或Future接口</p><p>线程池不会，贴个链接 <a href="https://liuzho.github.io/2017/04/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E8%BF%99%E4%B8%80%E7%AF%87%E6%88%96%E8%AE%B8%E5%B0%B1%E5%A4%9F%E4%BA%86/" target="_blank" rel="noopener">Java线程池</a>，准备单独学习下。</p><h3 id="stringbuilder和stringbuff有什么区别"><a href="#stringbuilder和stringbuff有什么区别" class="headerlink" title="stringbuilder和stringbuff有什么区别"></a>stringbuilder和stringbuff有什么区别</h3><p>这是倒数第二道问题，当时不知怎么回事实在想不起来，隐约记得与线程安全有关，但是之前答的不是很好加上紧张，就直接说想不起来了。还是基础太差惹的祸~谁给我的勇气投阿里…</p><p>stringbuilder不是线程安全的，stringbuff是线程安全的，用了synchronized关键字修饰。</p><hr><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="你熟悉哪些数据库？MySQL有哪些基本的数据类型"><a href="#你熟悉哪些数据库？MySQL有哪些基本的数据类型" class="headerlink" title="你熟悉哪些数据库？MySQL有哪些基本的数据类型"></a>你熟悉哪些数据库？MySQL有哪些基本的数据类型</h3><p>这里我只回答了int、float、double、long（实际上没有，相对应的是bigint）、char、varchar、timestamp、datetime。</p><p>MySQL的基本数据类型：</p><ul><li>数字类型<ul><li>整数: tinyint、smallint、mediumint、int、bigint</li><li>浮点数: float、double、real、decimal</li></ul></li><li>日期和时间: date、time、datetime、timestamp、year</li><li>字符串类型<ul><li>字符串: char、varchar</li><li>文本: tinytext、text、mediumtext、longtext</li></ul></li><li>二进制(可用来存储图片、音乐等): tinyblob、blob、mediumblob、longblob</li></ul><h3 id="那char和varchar的区别是什么？"><a href="#那char和varchar的区别是什么？" class="headerlink" title="那char和varchar的区别是什么？"></a>那char和varchar的区别是什么？</h3><p>（没答出来，忘了哎，之前还用的时候还特意去看过）</p><ul><li>char是定长的字符串，因此容易造成空间的浪费。char的最大长度为255个字符，查找效率比varchar高。</li><li>varchar是可变字符串，节省空间。实际长度是value长度+1，这一个字节用于保存实际使用了多大的长度，效率低于char。</li></ul><hr><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="计算机中除了硬盘之外还有哪些存储结构？"><a href="#计算机中除了硬盘之外还有哪些存储结构？" class="headerlink" title="计算机中除了硬盘之外还有哪些存储结构？"></a>计算机中除了硬盘之外还有哪些存储结构？</h3><p>寄存器、cache、内存</p><h3 id="哪个访问速度最快？"><a href="#哪个访问速度最快？" class="headerlink" title="哪个访问速度最快？"></a>哪个访问速度最快？</h3><p>寄存器，速度与CPU相当，但空间较小，在KB级别</p><hr><h2 id="算法与数据结构"><a href="#算法与数据结构" class="headerlink" title="算法与数据结构"></a>算法与数据结构</h2><h3 id="数据结构应该学过吧，你知道哪些数据结构？"><a href="#数据结构应该学过吧，你知道哪些数据结构？" class="headerlink" title="数据结构应该学过吧，你知道哪些数据结构？"></a>数据结构应该学过吧，你知道哪些数据结构？</h3><p>我回答 栈、队列、二叉树</p><h3 id="栈和队列有哪些区别？"><a href="#栈和队列有哪些区别？" class="headerlink" title="栈和队列有哪些区别？"></a>栈和队列有哪些区别？</h3><p>栈是先进后出，队列是先进先出</p><h3 id="能说下二叉平衡树是怎么实现平衡的？"><a href="#能说下二叉平衡树是怎么实现平衡的？" class="headerlink" title="能说下二叉平衡树是怎么实现平衡的？"></a>能说下二叉平衡树是怎么实现平衡的？</h3><p>这个真不知道，GG，老实跟他说不会。</p><p>照例先贴个链接 <a href="https://blog.csdn.net/zhangvalue/article/details/76691562" target="_blank" rel="noopener">平衡二叉树详解</a>，单独学习。</p><h3 id="你了解过哪些算法？"><a href="#你了解过哪些算法？" class="headerlink" title="你了解过哪些算法？"></a>你了解过哪些算法？</h3><p>我说我只了解过排序。。。</p><h3 id="你能说说冒泡排序的原理吗"><a href="#你能说说冒泡排序的原理吗" class="headerlink" title="你能说说冒泡排序的原理吗"></a>你能说说冒泡排序的原理吗</h3><p>每次循环都将最大或最小的值移动到末尾（这里我可能没有表述的太清楚）</p><p>复制个网上的答案：</p><blockquote><p><strong>冒泡排序</strong>（英语：<strong>Bubble Sort</strong>）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p></blockquote><h3 id="那冒泡排序在最坏的情况下需要移动多少次"><a href="#那冒泡排序在最坏的情况下需要移动多少次" class="headerlink" title="那冒泡排序在最坏的情况下需要移动多少次"></a>那冒泡排序在最坏的情况下需要移动多少次</h3><p>我回答了n(n-1)/2，其实这个是比较的次数，面试官友善的问我是否确定，疑惑了下还是说了确定 :(</p><p>事实上，答案是3n(n-1)/2，因为两个元素两两交换的时候你必须移动元素三次来达到交换的目的。如下，交换两个元素有4种方法：</p><ol><li><p>通过临时变量保存</p></li><li><p>a=a+b;</p><p>b=a-b;</p><p>a=a-b;</p><p><strong>不会发生溢出</strong>，即使造成的溢出会在后边的减运算中被溢出回来。</p></li><li><p>a=a*b;</p><p>b=a/b;</p><p>a=a/b;</p><p>类似第二种方法，但是溢出后无法交换，并且限制了b!=0</p></li><li><p>a=a^b;</p><p>b=b^a;</p><p>a=b^a;</p><p>效率最高的一种方法</p></li></ol><h3 id="那么最少呢？"><a href="#那么最少呢？" class="headerlink" title="那么最少呢？"></a>那么最少呢？</h3><p>0次。（面试官自己还带着恍然大悟的感觉重复了一遍…）</p><h3 id="让你实现一个函数，从1-…-n，你怎么实现？"><a href="#让你实现一个函数，从1-…-n，你怎么实现？" class="headerlink" title="让你实现一个函数，从1+…+n，你怎么实现？"></a>让你实现一个函数，从1+…+n，你怎么实现？</h3><p>想了半天还是跟他说n*(n+1)/2，感觉没有get到他的考点。于是问我为什么能够用这个公式，我说不知道。他说不就是等差数列求和么。我恍然大悟。</p><p>Google了下，感觉这道题目是为了考你的思维，让你给出多种解决方案</p><ol><li><p>循环</p></li><li><p>n*(n+1)/2</p></li><li><p>递归</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n + add(n-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不用加减乘除的做法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n &gt; <span class="number">0</span> ? (n == <span class="number">1</span> ? <span class="number">1</span> : (n += add(n - <span class="number">1</span>))) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等同于下面这种写法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> n += add3(n-<span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><hr></li></ol><h2 id="JVM与GC"><a href="#JVM与GC" class="headerlink" title="JVM与GC"></a>JVM与GC</h2><h3 id="说一说JVM内存模型"><a href="#说一说JVM内存模型" class="headerlink" title="说一说JVM内存模型"></a>说一说JVM内存模型</h3><p>栈、堆、方法区、本地方法区、程序计数器</p><h3 id="能说一说OOM吗"><a href="#能说一说OOM吗" class="headerlink" title="能说一说OOM吗"></a>能说一说OOM吗</h3><p>这里我只回答了除了程序计数器之外，其他区都会发生OOM。其他就不知道了，他也没继续问。。。</p><h3 id="垃圾回收你知道哪几种算法"><a href="#垃圾回收你知道哪几种算法" class="headerlink" title="垃圾回收你知道哪几种算法"></a>垃圾回收你知道哪几种算法</h3><p>标记清除、复制算法、标记整理</p><h3 id="标记清除算法能说说么"><a href="#标记清除算法能说说么" class="headerlink" title="标记清除算法能说说么"></a>标记清除算法能说说么</h3><p>分为标记和清除，首先标记出需要回收的对象，然后在标记完成后统一回收被标记的对象。但是他会出现空间问题，内存中会出现大量大不连续的空间，不利于大对象的分配。这里我将效率问题弄反了，记成了效率最高。实际上标记清除算法效率不高。</p><h3 id="那现在标记清楚算法还用吗？"><a href="#那现在标记清楚算法还用吗？" class="headerlink" title="那现在标记清楚算法还用吗？"></a>那现在标记清楚算法还用吗？</h3><p>我肯定的回答他还用。</p><p>事后翻阅相关书籍觉得我在这里回答的太笼统随意了，因为目前来说只有CMS垃圾收集器用了这个算法，对于其他的垃圾收集器，老年代用的都是标记-整理算法。</p><hr><h2 id="还记的我的名字么"><a href="#还记的我的名字么" class="headerlink" title="还记的我的名字么"></a>还记的我的名字么</h2><p>这个问题问我的时候我也是懵了，脑袋一片空白，怎能记起四十多分钟前暗藏在他自我介绍中的名字，想了想最后还是不好意思的说不知道，面试官自己也笑了笑说没事，并重复了一遍，“我的名字叫刘nan”<del>说实话，阿里的面试官挺幽默的，也让我对他的名字记忆犹新，不知道以后有没有机会进阿里，如果有一定请他吃个饭哈哈</del></p><hr><h2 id="感想"><a href="#感想" class="headerlink" title="感想"></a>感想</h2><p>谈谈自己的感想。</p><ul><li>先谈阿里。首先，作为一个二本的菜鸟，本来对收到阿里的面试并没有期待（道理你懂的），但是阿里还是给了机会，从这点看，我就觉得阿里挺有包容度的，或许这也是阿里能成为如此优秀的企业有关。</li><li>阿里的面试官。仅从声音上分辨，感觉是一个三十出头的小哥，声音很有底气。在面试上，一些你回答的错误，他也会友善地纠正，有时也会友情的提示你，对于技术上的问题，会问到你不会为止。最后，他真的挺幽默、有套路的哈哈，“最后一个问题：还记得我名字”<del>~</del></li><li>最后谈自己。首先，对于一个面试，心态没有很好的放平，虽然总暗示自己这只是一场面试，是一次学习的机会，但面试的时候还是很紧张，导致一些问题即使平常看到过，有印象，但就是答不出来。其次，还是基础不够扎实，对于一个Java开发工程师来说，最基本的Java基础没有掌握牢。对于JVM，GC，尽管之前看了两遍，自认为能够侃侃而谈，但实际上还却只是一知半解。一些基础的算法，即使学习的时候已经理解，但是还是要学会复习，并且需要学会去把控一些算法的细节，如时间、空间复杂度，移动、比较的次数等。</li></ul><p>So，Keep Going~</p><blockquote><p>大部分正义感都是虚伪的 聊胜于无   —————————————沃德彭尤·胡某</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDK9中HashMap关键变量与方法的分析</title>
      <link href="/2018/04/06/JDK9%E4%B8%ADHashMap%E7%9A%84%E5%88%86%E6%9E%90/"/>
      <url>/2018/04/06/JDK9%E4%B8%ADHashMap%E7%9A%84%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近准备面试，将自己的一些关于HashMap的理解记录于此，同时附上在Java9中对于HashMap的源码的分析。</p></blockquote><a id="more"></a><h1 id="原理图"><a href="#原理图" class="headerlink" title="原理图"></a>原理图</h1><p><img src="https://user-gold-cdn.xitu.io/2017/12/19/1606cca4f5b48e63?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>引用极客学院对于hashmap的摘要：</p><p>HashMap 是基于哈希表的 Map 接口的非同步实现。此实现提供所有可选的映射操作，并允许使用 null 值和 null 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p><p>此实现假定哈希函数将元素适当地分布在各桶之间，可为基本操作（get 和 put）提供稳定的性能。迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例。所以，如果迭代性能很重要，则不要将初始容量设置得太高或将加载因子设置得太低。</p><p>需要注意的是：Hashmap 不是同步的，如果多个线程同时访问一个 HashMap，而其中至少一个线程从结构上（指添加或者删除一个或多个映射关系的任何操作）修改了，则必须保持外部同步，以防止对映射进行意外的非同步访问。</p></blockquote><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h2><h3 id="table"><a href="#table" class="headerlink" title="table"></a>table</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, initialized on first use, and resized as</span></span><br><span class="line"><span class="comment"> * necessary. When allocated, length is always a power of two.</span></span><br><span class="line"><span class="comment"> * (We also tolerate length zero in some operations to allow</span></span><br><span class="line"><span class="comment"> * bootstrapping mechanics that are currently not needed.)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*这个table，在第一次使用时需要初始化并且会在需要的时候重新扩容。</span></span><br><span class="line"><span class="comment">*当在内存中分配时，这个table的长度总是2的幂次方。</span></span><br><span class="line"><span class="comment">*（为了允许引导机制在某些操作中我们也容忍零长度，但目前这些并不需要）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p>table是存储Node的数组，相当于HashMap的地基，而Node是一个静态内部类，继承了Map.Entry&lt;K,V&gt;这个接口，如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//哈希值</span></span><br><span class="line">      <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">      V value;<span class="comment">//值</span></span><br><span class="line">      Node&lt;K,V&gt; next;<span class="comment">//下一个节点</span></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">      Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">          <span class="keyword">this</span>.hash = hash;</span><br><span class="line">          <span class="keyword">this</span>.key = key;</span><br><span class="line">          <span class="keyword">this</span>.value = value;</span><br><span class="line">          <span class="keyword">this</span>.next = next;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">      *通过key的hashcode与value的hashcode 异或 得到新的hash值</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">          V oldValue = value;</span><br><span class="line">          value = newValue;</span><br><span class="line">          <span class="keyword">return</span> oldValue;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">              Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">              <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                  Objects.equals(value, e.getValue()))</span><br><span class="line">                  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="entrySet"><a href="#entrySet" class="headerlink" title="entrySet"></a>entrySet</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Holds cached entrySet(). Note that AbstractMap fields are used</span></span><br><span class="line"><span class="comment"> * for keySet() and values().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *保存缓存的entrySet()。注意，AbstractMap字段被用于keySet()和values()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><h3 id="size"><a href="#size" class="headerlink" title="size"></a>size</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The number of key-value mappings contained in this map.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*该HashMap中保存的键值对的数量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h3 id="modCount"><a href="#modCount" class="headerlink" title="modCount"></a>modCount</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The number of times this HashMap has been structurally modified</span></span><br><span class="line"><span class="comment"> * Structural modifications are those that change the number of mappings in</span></span><br><span class="line"><span class="comment"> * the HashMap or otherwise modify its internal structure (e.g.,</span></span><br><span class="line"><span class="comment"> * rehash).  This field is used to make iterators on Collection-views of</span></span><br><span class="line"><span class="comment"> * the HashMap fail-fast.  (See ConcurrentModificationException).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> *这个HashMap被结构化修改的次数</span></span><br><span class="line"><span class="comment"> *结构化修改是例如在这个HashMap中修改映射关系的数量或者修改其内部结构（例如 rehash）。这个变量被用  于在收集视图的快速失败中构建迭代器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><blockquote><p><code>fail-fast</code> 快速失败是Java集合的一种错误检测机制。当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast机制。记住是有可能，而不是一定。例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p></blockquote><h3 id="threshold"><a href="#threshold" class="headerlink" title="threshold"></a>threshold</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The next size value at which to resize (capacity * load factor).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// (The javadoc description is true upon serialization.</span></span><br><span class="line"><span class="comment">// Additionally, if the table array has not been allocated, this</span></span><br><span class="line"><span class="comment">// field holds the initial array capacity, or zero signifying</span></span><br><span class="line"><span class="comment">// DEFAULT_INITIAL_CAPACITY.)</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br></pre></td></tr></table></figure><p>当达到这个threshold（capacity * load factor）后，table会重新扩容<br>意味着默认情况构造情况下，当你存够12个时，table会第一次扩容</p><h3 id="loadFactor"><a href="#loadFactor" class="headerlink" title="loadFactor"></a>loadFactor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The load factor for the hash table.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>相关定义与解释请看下面的静态变量中的<a href="../JDK9中HashMap的分析/#DEFAULT-LOAD-FACTOR">DEFAULT_LOAD_FACTOR</a></p><h2 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h2><p>###DEFAULT_INITIAL_CAPACITY</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The default initial capacity - MUST be a power of two.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br></pre></td></tr></table></figure><p><strong>默认初始化容量</strong>，默认值为16，且必须是2的幂次方。不知道读者有没有注意到 <code>// aka 16</code> 这个注释，很奇怪aka是什么意思，Google上也没有合理的解释，知道的小伙伴们可以留言下：）</p><p>AND 还有个细节，为什么这个默认值不直接写成 16，而是写成了 1 &lt;&lt; 4。</p><p>StackOverflow上给出了一个合理的解释</p><blockquote><p>It’s to emphasize that the number is a power of two, and not a completely arbitrary choice. It thus nudges developers experimenting with different numbers to change it to other numbers in the pattern (e.g., <code>1 &lt;&lt; 3</code> or <code>1 &lt;&lt; 5</code>, rather than <code>25</code>) so they don’t break the code.</p><p>蹩脚的翻译：</p><p>这是为了强调DEFAULT_INITIAL_CAPACITY是2的幂次方而不是完全任意的选择。因此，这促使开发者尝试使用不同的数字来将其改变为符合其模式的数字（e.g.，…），这样不会让他们破坏代码。</p></blockquote><h3 id="DEFAULT-LOAD-FACTOR"><a href="#DEFAULT-LOAD-FACTOR" class="headerlink" title="DEFAULT_LOAD_FACTOR"></a>DEFAULT_LOAD_FACTOR</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">/**</span></span><br><span class="line"><span class="comment">* The load factor used when none specified in constructor.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&gt;<span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br></pre></td></tr></table></figure></blockquote><p><strong>默认载入因子</strong>，默认值为0.75。</p><p>在这里提出两个问题：</p><ul><li>什么是载入因子？</li></ul><p>  载入因子是表示Hsah表中元素的填满的程度。<br>  加载因子越大,填满的元素越多,空间利用率越高，但Hash冲突的机会加大了。<br>  反之,加载因子越小,填满的元素越少,Hash冲突的机会减小,但空间浪费多了。<br>  Hash冲突的机会越大,则查找的成本越高。反之,查找的成本越小。</p><ul><li>为什么默认值为0.75？</li></ul><p>源码中有这么一段</p><blockquote><p>Because TreeNodes are about twice the size of regular nodes, we use them only when bins contain enough nodes to warrant use (see TREEIFY_THRESHOLD). And when they become too small (due to removal or resizing) they are converted back to plain bins.  In usages with well-distributed user hashCodes, tree bins are rarely used.  Ideally, under random hashCodes, the frequency of nodes in bins follows a Poisson distribution (<a href="http://en.wikipedia.org/wiki/Poisson_distribution" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Poisson_distribution</a>) with a parameter of about 0.5 on average for the default resizing threshold of 0.75, although with a large variance because of resizing granularity. Ignoring variance, the expected occurrences of list size k are (exp(-0.5) * pow(0.5, k) / factorial(k)).The first values are:</p><ul><li>0:    0.60653066</li><li>1:    0.30326533</li><li>2:    0.07581633</li><li>3:    0.01263606</li><li>4:    0.00157952</li><li>5:    0.00015795</li><li>6:    0.00001316</li><li>7:    0.00000094</li><li>8:    0.00000006</li><li>more: less than 1 in ten million</li></ul></blockquote><p>大意就是在理想情况下,使用随机哈希码,节点出现的频率在hash桶中遵循<a href="http://www.ruanyifeng.com/blog/2015/06/poisson-distribution.html" target="_blank" rel="noopener">泊松分布</a>，同时给出了桶中元素个数和概率的对照表。从上面的表中可以看到当桶中元素到达8个的时候，概率已经变得非常小，也就是说用0.75作为加载因子，每个碰撞位置的链表长度超过８个是几乎不可能的。</p><p><strong>总而言之，0.75能够让HashMap在 “冲突的机会”与”空间利用率”之间寻找一种平衡与折衷，这样既不会出现太大的冲突，又能够很好的利用空间。</strong></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="getNode-int-hash-Object-key"><a href="#getNode-int-hash-Object-key" class="headerlink" title="getNode(int hash, Object key)"></a>getNode(int hash, Object key)</h2><p>大致思路如下</p><ol><li>先查找tab[(n - 1) &amp; hash]，命中则返回，否则继续</li></ol><ol start="2"><li><p>若tab[(n - 1) &amp; hash]节点为树，则在树中查找，时间复杂度为O(logn)</p></li><li><p>若为链表，则在链表中查找，时间复杂度为O(n)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//当table不为null，长度大于0并且根据(n - 1) &amp; hash 得到对应的节点Node不为null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果传进来的hash与key与索引对应的链表（红黑树）的Node的key与hash相同，则表明找到了</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//当存在下一个节点时</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果第一个节点属于红黑树，那么在红黑树中进行查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//链表查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>(n - 1) &amp; hash 的作用是什么？</li></ul><p>相当于%（取模）操作，防止hash out of range.<br>StackOverflow（OK，又是你~）上也有外国朋友问了<a href="https://stackoverflow.com/questions/27230938/why-hashmap-insert-new-node-on-index-n-1-hash" target="_blank" rel="noopener">该问题</a></p><ul><li>接着上一题问，那为什么不用%而用了&amp;？</li></ul><p>首先，对于现代的处理器来说，除法和求余数（模运算）是最慢的动作。</p><p>其次，由于在HashMap中，容量一定为2的幂次方。所以当b为2的幂次方时，如下等式成立 <code>a % b == (b-1) &amp; a</code></p><h2 id="putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict"><a href="#putVal-int-hash-K-key-V-value-boolean-onlyIfAbsent-boolean-evict" class="headerlink" title="putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)"></a>putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)</h2><p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%20put%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//如果table为null或长度为0，那么扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果对应的节点Node为null，新建一个Node节点并插入键值对，此时没有冲突</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">//若存在冲突</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//如果第一个节点刚好匹配key，直接跳出循环，在循环外覆盖旧值</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果为树节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">//红黑树插入键值对</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">//如果为链表</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//先插入键值对</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">//如果链表长度大于TREEIFY_THRESHOLD（8），那么将该链表构造为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果在链表中匹配到了key，直接跳出循环，在循环外覆盖旧值</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果能够匹配key</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">//将新的值替换旧的值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//判断是否需要resize即是否超过threshold = capacity * load factor</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="hash-Object-key"><a href="#hash-Object-key" class="headerlink" title="hash(Object key)"></a>hash(Object key)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Computes key.hashCode() and spreads (XORs) higher bits of hash</span></span><br><span class="line"><span class="comment">    * to lower.  Because the table uses power-of-two masking, sets of</span></span><br><span class="line"><span class="comment">    * hashes that vary only in bits above the current mask will</span></span><br><span class="line"><span class="comment">    * always collide. (Among known examples are sets of Float keys</span></span><br><span class="line"><span class="comment">    * holding consecutive whole numbers in small tables.)  So we</span></span><br><span class="line"><span class="comment">    * apply a transform that spreads the impact of higher bits</span></span><br><span class="line"><span class="comment">    * downward. There is a tradeoff between speed, utility, and</span></span><br><span class="line"><span class="comment">    * quality of bit-spreading. Because many common sets of hashes</span></span><br><span class="line"><span class="comment">    * are already reasonably distributed (so don't benefit from</span></span><br><span class="line"><span class="comment">    * spreading), and because we use trees to handle large sets of</span></span><br><span class="line"><span class="comment">    * collisions in bins, we just XOR some shifted bits in the</span></span><br><span class="line"><span class="comment">    * cheapest possible way to reduce systematic lossage, as well as</span></span><br><span class="line"><span class="comment">    * to incorporate impact of the highest bits that would otherwise</span></span><br><span class="line"><span class="comment">    * never be used in index calculations because of table bounds.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**  Google Translation~</span></span><br><span class="line"><span class="comment">         计算key.hashCode（）并散布（XOR）高位散列</span></span><br><span class="line"><span class="comment">         降低。 由于该表使用幂的两个掩码，</span></span><br><span class="line"><span class="comment">         散列值只会在当前掩码之上的位上发生变化</span></span><br><span class="line"><span class="comment">         总是碰撞。 （在已知的例子中是Float键的集合</span></span><br><span class="line"><span class="comment">         在小表中保持连续的整数）。所以我们</span></span><br><span class="line"><span class="comment">         应用扩展高位影响的变换</span></span><br><span class="line"><span class="comment">         向下。 在速度，效用和方法之间进行权衡</span></span><br><span class="line"><span class="comment">         比特扩散的质量。 因为许多常见的哈希集合</span></span><br><span class="line"><span class="comment">         已经合理分配（所以不会从中受益</span></span><br><span class="line"><span class="comment">         传播），并且因为我们使用树来处理大量的</span></span><br><span class="line"><span class="comment">         在箱中发生碰撞，我们只是在XOR中异或</span></span><br><span class="line"><span class="comment">         最便宜的方法来减少系统损失，以及</span></span><br><span class="line"><span class="comment">         合并否则会影响最高位</span></span><br><span class="line"><span class="comment">         由于表的边界，决不会用于索引计算。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> h;</span><br><span class="line">       <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>一句话解释为什么要这么做？<strong>为了更好的让存储的下标均匀分布，尽可能的减少hash碰撞</strong></p><p>WHY？</p><blockquote><p>首先，假设有一种情况，对象 A 的 hashCode 为 1000010001110001000001111000000，对象 B 的 hashCode 为 0111011100111000101000010100000。</p><p>如果数组长度是16，也就是 15 与运算这两个数， 你会发现结果都是0。这样的散列结果太让人失望了。很明显不是一个好的散列算法。</p><p>但是如果我们将 hashCode 值右移 16 位，也就是取 int 类型的一半，刚好将该二进制数对半切开。并且使用位异或运算（如果两个数对应的位置相反，则结果为1，反之为0），这样的话，就能避免我们上面的情况的发生。</p><p>总的来说，使用位移 16 位和 异或 就是防止这种极端情况。但是，该方法在一些极端情况下还是有问题，比如：10000000000000000000000000(33554432) 和 10000000000100000000000000(33570816) 这两个数，如果数组长度是16，那么即使右移16位，在异或，hash 值还是会重复。但是为了性能，对这种极端情况，JDK 的作者选择了性能。毕竟这是少数情况，为了这种情况去增加 hash 时间，性价比不高。</p></blockquote><h2 id="resize"><a href="#resize" class="headerlink" title="resize()"></a>resize()</h2><p>分析resize()函数之前，先提出一个问题：</p><ul><li>如果重新扩容，那么势必会导致tab[(n-1)&amp;hash]中的index不同，以致于无法找到对应的键值对，怎么办？</li></ul><ol><li>对所有的键值对重新执行putVal(int hash, K key, V value, boolean onlyIfAbsent,boolean evict)操作。这么做开销很大，只在JDK8之前这么做<br><img src="https://tech.meituan.com/img/java-hashmap/jdk1.7%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt=""></li><li>经过观测可以发现，我们使用的是2次幂的扩展(指长度扩为原来2倍)，所以，元素的位置要么是在原位置，要么是在原位置再移动2次幂的位置。如下图可以明白这句话的意思，n为table的长度，图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，其中hash1是key1对应的哈希与高位运算结果。</li></ol><p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE1.png" alt=""></p><p>​    元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><p><img src="https://tech.meituan.com/img/java-hashmap/hashMap%201.8%20%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95%E4%BE%8B%E5%9B%BE2.png" alt=""></p><p>​    因此，我们在扩充HashMap的时候，不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”，可以看看下图为16扩充为32的resize示意图：</p><p><img src="https://tech.meituan.com/img/java-hashmap/jdk1.8%20hashMap%E6%89%A9%E5%AE%B9%E4%BE%8B%E5%9B%BE.png" alt=""></p><p>​    这个设计确实非常的巧妙，既省去了重新计算hash值的时间，而且同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的newTable了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">    * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">    * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">    * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">    * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*初始化或者加倍table的大小。如果为null，那么分配空间【这段实在不知道该怎么翻译了：）】</span></span><br><span class="line"><span class="comment">*否则，由于我们使用了幂级别的扩展，那么在table中每个桶中的元素要么保持相同的索引，要么移动两倍的偏移</span></span><br><span class="line"><span class="comment">*量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">//如果容量超过最大值2^30，无法扩容了，那么只能让其碰撞，</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//没超过最大值，那么扩大为原来的2倍</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               <span class="comment">//threshold也需要扩大为2倍，否则下次触发resize时，用的还是原先的threshold，因此会提前扩容</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">           Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="comment">//原先table上的Node不为空</span></span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="comment">//如果仅仅存在一个Node，重新计算index并放置进newTab中</span></span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       <span class="comment">//红黑树分裂</span></span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="comment">//节点后为链表</span></span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="comment">// 原索引</span></span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 原索引 + oldCap</span></span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">//原索引放到newTab里</span></span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//原索引 + oldCap 放到newTab里</span></span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><ol><li>扩容是一个特别耗性能的操作，所以当程序员在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</li><li>负载因子是可以修改的，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</li><li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</li><li>JDK8之后引入红黑树大程度优化了HashMap的性能。</li></ol></blockquote><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://my.oschina.net/weiweiblog/blog/612812" target="_blank" rel="noopener">https://my.oschina.net/weiweiblog/blog/612812</a></p><p><a href="https://www.jianshu.com/p/dff8f4641814" target="_blank" rel="noopener">https://www.jianshu.com/p/dff8f4641814</a></p><p><a href="https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">https://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/</a></p><p><a href="https://blog.csdn.net/qq_38182963/article/details/78940047#comments" target="_blank" rel="noopener">https://blog.csdn.net/qq_38182963/article/details/78940047#comments</a></p><p><a href="https://tech.meituan.com/java-hashmap.html" target="_blank" rel="noopener">https://tech.meituan.com/java-hashmap.html</a></p><blockquote><p>大部分正义感都是虚伪的 聊胜于无   —————————————沃德彭尤·胡某</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
